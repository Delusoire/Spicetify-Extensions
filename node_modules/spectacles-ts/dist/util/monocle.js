"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lensFromPath = exports.traversalFromPath = exports.optionalFromPath = exports.isPathTraversal = exports.isPathLens = void 0;
const function_1 = require("fp-ts/function");
const A = __importStar(require("fp-ts/ReadonlyArray"));
const R = __importStar(require("fp-ts/ReadonlyRecord"));
const string_1 = require("fp-ts/string");
const L = __importStar(require("monocle-ts/lib/Lens"));
const Op = __importStar(require("monocle-ts/lib/Optional"));
const Tr = __importStar(require("monocle-ts/lib/Traversal"));
const isPathLens = (path) => !split(path).some((s) => ["?", "?some", "?left", "right", "[]>", "{}>", "[number]", "[string]"].includes(s) ||
    (!s.startsWith("(") && s.includes(":")));
exports.isPathLens = isPathLens;
const isPathTraversal = (path) => split(path).some((s) => ["[]>", "{}>"].includes(s));
exports.isPathTraversal = isPathTraversal;
const lastSegment = (path) => {
    if (path === "") {
        return path;
    }
    const escapeable = path.match(/\((.*)\*(.*)\)$/);
    if (escapeable) {
        return escapeable[2];
    }
    const escapeable2 = path.match(/\((.*)\)$/);
    if (escapeable2) {
        return escapeable2[0];
    }
    const finalSegment = path.match(/(.*)\.(.*)/);
    if (finalSegment) {
        return finalSegment[2];
    }
    return path;
};
const initSegment = (path) => {
    if (path === "") {
        return path;
    }
    const escapeable = path.match(/(.*)\.\((.*)\*(.*)\)$/);
    if (escapeable) {
        return escapeable[1];
    }
    return path.substring(0, path.lastIndexOf(lastSegment(path)) - 1);
};
const splitIntoSegments = (path, acc = []) => {
    const init = initSegment(path);
    const last = lastSegment(path);
    if (init === "") {
        return [last, ...acc];
    }
    return splitIntoSegments(init, [last, ...acc]);
};
const split = (path) => {
    const segments = splitIntoSegments(path, []);
    return segments.flatMap((segment) => {
        if (segment.includes("?some") ||
            segment.includes("?left") ||
            segment.includes("?right") ||
            !segment.includes("?")) {
            return [segment];
        }
        else {
            const before = segment.substring(0, segment.length - 1);
            if (before.length > 0) {
                return [before, "?"];
            }
            return ["?"];
        }
    });
};
const optionalFromPath = (path, _indicies) => {
    const indicies = [..._indicies];
    const opt = split(path).reduce((acc, cur) => {
        if (cur === "?") {
            return (0, function_1.pipe)(acc, Op.fromNullable);
        }
        else if (cur === "?some") {
            return (0, function_1.pipe)(acc, Op.some);
        }
        else if (cur === "?left") {
            return (0, function_1.pipe)(acc, Op.left);
        }
        else if (cur === "?right") {
            return (0, function_1.pipe)(acc, Op.left);
        }
        else if (cur === "[number]") {
            return (0, function_1.pipe)(acc, Op.index(indicies.shift()));
        }
        else if (cur === "[string]") {
            return (0, function_1.pipe)(acc, Op.key(indicies.shift()));
        }
        else if (cur.includes("[") && cur.includes("]") && cur.indexOf("[") < cur.indexOf("]")) {
            const component = Number.parseInt(cur.substring(cur.indexOf("[") + 1, cur.indexOf("]")), 10);
            return (0, function_1.pipe)(acc, Op.component(component));
        }
        else if (cur.includes(":")) {
            const i = cur.indexOf(":");
            const discriminant = cur.substring(0, i);
            const member = cur.substring(i + 1, cur.length);
            return (0, function_1.pipe)(acc, Op.filter((a) => a[discriminant] === member));
        }
        return (0, function_1.pipe)(acc, Op.prop(cur));
    }, Op.id());
    return opt;
};
exports.optionalFromPath = optionalFromPath;
const traversalFromPath = (path, _indicies) => {
    const indicies = [..._indicies];
    const opt = split(path).reduce((acc, cur) => {
        if (cur === "?") {
            return (0, function_1.pipe)(acc, Tr.fromNullable);
        }
        else if (cur === "?some") {
            return (0, function_1.pipe)(acc, Tr.some);
        }
        else if (cur === "?left") {
            return (0, function_1.pipe)(acc, Tr.left);
        }
        else if (cur === "?right") {
            return (0, function_1.pipe)(acc, Tr.left);
        }
        else if (cur === "[number]") {
            return (0, function_1.pipe)(acc, Tr.index(indicies.shift()));
        }
        else if (cur === "[string]") {
            return (0, function_1.pipe)(acc, Tr.key(indicies.shift()));
        }
        else if (cur === "[]>") {
            const a = (0, function_1.pipe)(acc, Tr.traverse(A.Traversable));
            return a;
        }
        else if (cur === "{}>") {
            const a = (0, function_1.pipe)(acc, Tr.traverse(R.getTraversable(string_1.Ord)));
            return a;
        }
        else if (cur.includes("[") && cur.includes("]") && cur.indexOf("[") < cur.indexOf("]")) {
            const component = Number.parseInt(cur.substring(cur.indexOf("[") + 1, cur.indexOf("]")), 10);
            return (0, function_1.pipe)(acc, Tr.component(component));
        }
        else if (cur.includes(":")) {
            const i = cur.indexOf(":");
            const discriminant = cur.substring(0, i);
            const member = cur.substring(i + 1, cur.length);
            return (0, function_1.pipe)(acc, Tr.filter((a) => a[discriminant] === member));
        }
        return (0, function_1.pipe)(acc, Tr.prop(cur));
    }, Tr.id());
    return opt;
};
exports.traversalFromPath = traversalFromPath;
const lensFromPath = (path) => {
    const lens = split(path).reduce((acc, cur) => {
        if (cur.includes("[") && cur.includes("]") && cur.indexOf("[") < cur.indexOf("]")) {
            const component = cur.substring(cur.indexOf("[") + 1, cur.indexOf("]"));
            return (0, function_1.pipe)(acc, L.component(Number.parseInt(component, 10)));
        }
        return (0, function_1.pipe)(acc, L.prop(cur));
    }, L.id());
    return lens;
};
exports.lensFromPath = lensFromPath;
