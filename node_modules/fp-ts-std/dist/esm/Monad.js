import { pipe } from "fp-ts/function";
import * as A from "fp-ts/Array";
import { invert } from "./Boolean";
export function ifM(M) {
    return p => x => y => M.chain(p, b => (b ? x : y));
}
export function andM(M) {
    return x => y => M.chain(x, b => (b ? y : M.of(false)));
}
export function orM(M) {
    return x => y => M.chain(x, b => (b ? M.of(true) : y));
}
export function allPassM(M) {
    return fs => x => pipe(fs, A.reduce(M.of(true), (m, f) => M.chain(m, b => (b ? f(x) : M.of(false)))));
}
export function anyPassM(M) {
    return fs => x => pipe(fs, A.reduce(M.of(false), (m, f) => M.chain(m, b => (b ? M.of(true) : f(x)))));
}
export function nonePassM(M) {
    return fs => x => pipe(fs, A.reduce(M.of(true), (m, f) => M.chain(m, b => (b ? M.map(f(x), invert) : M.of(false)))));
}
export function whenM(M) {
    return b => x => M.chain(b, bb => (bb ? x : M.of(undefined)));
}
export function unlessM(M) {
    return b => x => M.chain(b, bb => (bb ? M.of(undefined) : x));
}
