import { constant, identity } from "fp-ts/function";
import { flap as flap_, bindTo as bindTo_, let as let__, } from "fp-ts/Functor";
import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, } from "fp-ts/Apply";
import { bind as bind_, chainFirst as chainFirst_ } from "fp-ts/Chain";
import * as RNEA from "fp-ts/ReadonlyNonEmptyArray";
import * as RA from "fp-ts/ReadonlyArray";
export const URI = "Lazy";
const _map = (f, g) => () => g(f());
const _ap = (f, g) => () => f()(g());
const _chain = (f, g) => g(f());
const _chainRec = (a, f) => () => {
    let e = f(a)();
    while (e._tag === "Left") {
        e = f(e.left)();
    }
    return e.right;
};
export const map = (f) => (fa) => _map(fa, f);
export const ap = fa => fab => _ap(fab, fa);
export const of = constant;
export const chain = f => ma => _chain(ma, f);
export const flatMap = chain;
export const flatten = chain(identity);
export const Functor = {
    URI,
    map: _map,
};
export const flap = flap_(Functor);
export const Pointed = {
    URI,
    of,
};
export const Apply = {
    URI,
    map: _map,
    ap: _ap,
};
export const apFirst = apFirst_(Apply);
export const apSecond = apSecond_(Apply);
export const Applicative = {
    URI,
    map: _map,
    ap: _ap,
    of,
};
export const Chain = {
    URI,
    map: _map,
    ap: _ap,
    chain: _chain,
};
export const Monad = {
    URI,
    map: _map,
    ap: _ap,
    of,
    chain: _chain,
};
export const chainFirst = chainFirst_(Chain);
export const ChainRec = {
    URI,
    map: _map,
    ap: _ap,
    chain: _chain,
    chainRec: _chainRec,
};
export const Do = of({});
export const bindTo = bindTo_(Functor);
export const bind = bind_(Chain);
export const apS = apS_(Apply);
const let_ = let__(Functor);
export { let_ as let, };
export const ApT = of([]);
export const traverseReadonlyNonEmptyArrayWithIndex = (f) => (as) => () => {
    const out = [f(0, RNEA.head(as))()];
    for (let i = 1; i < as.length; i++) {
        out.push(f(i, as[i])());
    }
    return out;
};
export const traverseReadonlyArrayWithIndex = (f) => {
    const g = traverseReadonlyNonEmptyArrayWithIndex(f);
    return as => (RA.isNonEmpty(as) ? g(as) : ApT);
};
export const traverseArrayWithIndex = traverseReadonlyArrayWithIndex;
export const traverseArray = (f) => traverseReadonlyArrayWithIndex((_, a) => f(a));
export const sequenceArray = traverseArray(identity);
export const execute = (x) => x();
export const lazy = identity;
export const memoize = (f) => {
    const empty = Symbol();
    let res = empty;
    return () => (res === empty ? (res = f()) : res);
};
