import { pipe, flow, flip } from "fp-ts/function";
import { and, not } from "fp-ts/Predicate";
import * as O from "fp-ts/Option";
import * as NEA from "fp-ts/NonEmptyArray";
import * as RA from "fp-ts/ReadonlyArray";
import * as S from "fp-ts/string";
import { join, dropRightWhile as dropRightWhileRA, takeRightWhile as takeRightWhileRA, } from "./ReadonlyArray";
import { max } from "fp-ts/Ord";
import { Ord as ordNumber } from "fp-ts/number";
import { invoke, when } from "./Function";
export const fromNumber = String;
export const prepend = (prepended) => rest => prepended + rest;
export const unprepend = (start) => when(S.startsWith(start))(dropLeft(start.length));
export const append = flip(prepend);
export const unappend = (end) => when(S.endsWith(end))(dropRight(end.length));
export const surround = (x) => flow(prepend(x), append(x));
export const unsurround = (x) => when(and(S.startsWith(x))(S.endsWith(x)))(flow(unprepend(x), unappend(x)));
export const takeLeft = (n) => S.slice(0, max(ordNumber)(0, n));
export const takeRight = (n) => x => S.slice(max(ordNumber)(0, x.length - Math.floor(n)), Infinity)(x);
export const match = (r) => flow(invoke("match")([r]), O.fromNullable);
export const matchAll = (r) => (x) => pipe(O.tryCatch(() => x.matchAll(r)), O.chain(flow(xs => Array.from(xs), NEA.fromArray)));
export const under = (f) => flow(S.split(""), f, join(""));
export const reverse = under(RA.reverse);
export const lines = S.split(/\r\n|\r|\n/);
export const unlines = join("\n");
export const test = (r) => x => {
    const lastIndex = r.lastIndex;
    const res = r.test(x);
    r.lastIndex = lastIndex;
    return res;
};
export const replaceAll = (r) => (s) => invoke("replace")([new RegExp(r, "g"), s]);
export const dropLeft = (n) => invoke("substring")([n]);
export const dropRight = (n) => x => pipe(x, invoke("substring")([0, x.length - Math.floor(n)]));
export const dropLeftWhile = (f) => pipe(RA.dropLeftWhile(f), under);
export const dropRightWhile = flow(dropRightWhileRA, under);
export const head = flow(O.fromPredicate(not(S.isEmpty)), O.map(takeLeft(1)));
export const tail = flow(O.fromPredicate(not(S.isEmpty)), O.map(dropLeft(1)));
export const last = flow(O.fromPredicate(not(S.isEmpty)), O.map(takeRight(1)));
export const init = flow(O.fromPredicate(not(S.isEmpty)), O.map(dropRight(1)));
export const lookup = (i) => (x) => pipe(x[i], O.fromNullable);
export const takeLeftWhile = flow(f => RA.takeLeftWhile(f), under);
export const takeRightWhile = flow(takeRightWhileRA, under);
export const splitAt = (index) => (str) => [S.slice(0, index)(str), S.slice(index, Infinity)(str)];
export const isAlpha = test(/^\p{Alpha}+$/u);
export const isAlphaNum = test(/^(\p{Alpha}|\p{Number})+$/u);
export const isLower = test(/^\p{Lower}+$/u);
export const isUpper = test(/^\p{Upper}+$/u);
export const isSpace = test(/^\s+$/);
export const words = S.split(/\s/);
export const unwords = join(" ");
