import { flow, identity, pipe } from "fp-ts/function";
import { not, and } from "fp-ts/Predicate";
import * as O from "fp-ts/Option";
import { unless } from "./Function";
import { Bounded as BoundedInfinity } from "fp-ts/number";
import * as A from "fp-ts/Array";
import * as L from "./Lazy";
export const isValid = not(Number.isNaN);
export const fromStringWithRadix = (radix) => (string) => pipe(Number.parseInt(string, radix), O.fromPredicate(isValid));
export const fromString = fromStringWithRadix(10);
export const floatFromString = flow(Number.parseFloat, O.fromPredicate(isValid));
export const increment = x => x + 1;
export const decrement = x => x - 1;
export const add = (x) => y => x + y;
export const multiply = (x) => y => x * y;
export const subtract = (subtrahend) => minuend => minuend - subtrahend;
export const divide = (divisor) => dividend => dividend / divisor;
export const rem = (divisor) => dividend => dividend % divisor;
export const mod = (divisor) => dividend => ((dividend % divisor) + divisor) % divisor;
export const negate = n => -n;
export const isFinite = n => Math.abs(n) !== Infinity;
export const toFinite = unless(isFinite)(n => Math.sign(n) * Number.MAX_SAFE_INTEGER);
export const isPositive = n => Math.sign(n) === 1;
export const isNegative = n => Math.sign(n) === -1;
export const isNonNegative = n => Math.sign(n) !== -1;
export const isNonPositive = n => Math.sign(n) !== 1;
export const BoundedSafe = {
    ...BoundedInfinity,
    top: Number.MAX_SAFE_INTEGER,
    bottom: Number.MIN_SAFE_INTEGER,
};
export const EnumInt = {
    ...BoundedSafe,
    succ: flow(O.fromPredicate(and((n) => n < Number.MAX_SAFE_INTEGER)(Number.isInteger)), O.map(increment)),
    pred: flow(O.fromPredicate(and((n) => n > Number.MIN_SAFE_INTEGER)(Number.isInteger)), O.map(decrement)),
    toEnum: O.some,
    fromEnum: identity,
    cardinality: L.of(Infinity),
};
export const digits = (n) => pipe([...(n + "")], A.filterMap(fromString));
