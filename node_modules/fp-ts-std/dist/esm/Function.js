import * as O from "fp-ts/Option";
import * as M from "fp-ts/Map";
import * as A from "fp-ts/Array";
import { flow, pipe, getMonoid as getFunctionMonoid, apply, constant, flip, tupled, } from "fp-ts/function";
import { not } from "fp-ts/Predicate";
import { getMonoid as getEndoMonoid } from "fp-ts/Endomorphism";
import { concatAll } from "fp-ts/Monoid";
import { first } from "fp-ts/Semigroup";
import { bindTo as bindTo_, let as let__ } from "fp-ts/Functor";
import { apFirst as apFirst_, apSecond as apSecond_, apS as apS_, } from "fp-ts/Apply";
import { bind as bind_ } from "fp-ts/Chain";
export const URI = "Function";
export const map = f => g => flow(g, f);
export const Functor = {
    URI,
    map: (f, g) => map(g)(f),
};
export const of = constant;
export const ap = f => g => x => g(x)(f(x));
export const Applicative = {
    ...Functor,
    of,
    ap: (f, g) => ap(g)(f),
};
export const apFirst = apFirst_(Applicative);
export const apSecond = apSecond_(Applicative);
export const chain = f => g => x => f(g(x))(x);
export const flatMap = chain;
export const Monad = {
    ...Applicative,
    chain: (f, g) => chain(g)(f),
};
export const Do = of({});
export const bindTo = bindTo_(Functor);
export const bind = bind_(Monad);
export const apS = apS_(Applicative);
const let_ = let__(Functor);
export { let_ as let, };
export const withIndex = f => g => xs => {
    let i = 0;
    return f(y => g(i++)(y))(xs);
};
export const unary = tupled;
export const guard = (branches) => (fallback) => (input) => pipe(branches, A.map(([f, g]) => flow(O.fromPredicate(f), O.map(g))), concatAll(getFunctionMonoid(O.getMonoid(first()))()), apply(input), O.getOrElse(() => fallback(input)));
export const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);
export const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);
export const when = flow(not, unless);
export const until = (f) => (g) => {
    const h = x => (f(x) ? x : h(g(x)));
    return h;
};
export const construct = (x) => (xs) => new x(...xs);
export const invoke = (x) => (ys) => (z) => z[x](...ys);
export const invokeNullary = flip(invoke)([]);
export const invokeOn = () => (x) => ys => z => z[x](...ys);
export const memoize = (eq) => (f) => {
    const cache = new Map();
    return k => {
        const cached = M.lookup(eq)(k)(cache);
        if (O.isSome(cached))
            return cached.value;
        const val = f(k);
        cache.set(k, val);
        return val;
    };
};
export const curry2T = (f) => (a) => (b) => f([a, b]);
export const curry2 = flow(unary, curry2T);
export const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);
export const curry3 = flow(unary, curry3T);
export const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);
export const curry4 = flow(unary, curry4T);
export const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);
export const curry5 = flow(unary, curry5T);
export const uncurry2 = (f) => ([a, b]) => f(a)(b);
export const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);
export const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);
export const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);
export function fork(fs) {
    return (x) => fs.map(f => f(x));
}
export const converge = (f) => (gs) => flow(x => fork(gs)(x), f);
export const isInstanceOf = (x) => (y) => y instanceof x;
export const applyEvery = concatAll(getEndoMonoid());
export const applySomes = (fs) => x => pipe(fs, A.reduce(x, (y, mf) => pipe(mf, O.match(constant(y), apply(y)))));
export const applyN = (n) => (f) => pipe(A.replicate(n, f), applyEvery);
