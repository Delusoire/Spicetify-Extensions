import { flow } from "fp-ts/function";
import { not } from "fp-ts/Predicate";
import * as RR from "fp-ts/ReadonlyRecord";
import * as RA from "fp-ts/ReadonlyArray";
import * as RT from "fp-ts/ReadonlyTuple";
import { last } from "fp-ts/Semigroup";
import { elemV } from "./ReadonlyArray";
import * as Str from "fp-ts/string";
export const values = Object.values;
export const lookupV = (x) => (k) => RR.lookup(k)(x);
export const reject = (f) => RR.filter(not(f));
export const invertLast = (f) => flow(RR.toReadonlyArray, RA.map(flow(RT.mapSnd(f), RT.swap)), RR.fromFoldable(last(), RA.Foldable));
export const invertAll = (f) => flow(RR.toReadonlyArray, RA.map(flow(RT.bimap(f, RA.of), RT.swap)), RR.fromFoldable(RA.getMonoid(), RA.Foldable));
export const pick = (ks) => RR.filterWithIndex(elemV(Str.Eq)(ks));
export const omit = (ks) => RR.filterWithIndex(not(elemV(Str.Eq)(ks)));
