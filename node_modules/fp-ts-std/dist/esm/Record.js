import { flow } from "fp-ts/function";
import { not } from "fp-ts/Predicate";
import * as R from "fp-ts/Record";
import * as A from "fp-ts/Array";
import * as T from "fp-ts/Tuple";
import { last } from "fp-ts/Semigroup";
import { elemV } from "./Array";
import * as Str from "fp-ts/string";
export const values = Object.values;
export const lookupV = (x) => (k) => R.lookup(k)(x);
export const reject = (f) => R.filter(not(f));
export const invertLast = (f) => flow(R.toArray, A.map(flow(T.mapSnd(f), T.swap)), R.fromFoldable(last(), A.Foldable));
export const invertAll = (f) => flow(R.toArray, A.map(flow(T.bimap(f, A.of), T.swap)), R.fromFoldable(A.getMonoid(), A.Foldable));
export const pick = (ks) => R.filterWithIndex(elemV(Str.Eq)(ks));
export const omit = (ks) => R.filterWithIndex(not(elemV(Str.Eq)(ks)));
