import * as O from "fp-ts/Option";
import * as R from "fp-ts/Record";
import { flow, pipe } from "fp-ts/function";
import { construct, invoke, isInstanceOf } from "./Function";
import * as NEA from "fp-ts/NonEmptyArray";
import * as A from "fp-ts/Array";
import { fromIterable } from "./Array";
import { mapSnd } from "fp-ts/Tuple";
import * as Str from "fp-ts/string";
import { withFst } from "./Tuple";
export const empty = construct(URLSearchParams)([]);
export const isEmpty = u => Array.from(u.keys()).length === 0;
export const fromString = (x) => pipe([x], construct(URLSearchParams));
export const toString = (x) => x.toString();
export const fromTuples = (x) => pipe([x], construct(URLSearchParams));
export const toTuples = (x) => pipe(x.entries(), fromIterable);
export const fromRecord = flow(R.foldMapWithIndex(Str.Ord)(A.getMonoid())((k, vs) => pipe(vs, A.map(withFst(k)))), fromTuples);
export const toRecord = (x) => R.fromFoldableMap(NEA.getSemigroup(), A.Foldable)(toTuples(x), mapSnd(NEA.of));
export const clone = (x) => pipe([x], construct(URLSearchParams));
export const isURLSearchParams = isInstanceOf(URLSearchParams);
export const getParam = (k) => flow(invoke("get")([k]), O.fromNullable);
export const getAllForParam = (k) => flow(invoke("getAll")([k]), NEA.fromArray);
export const setParam = (k) => (v) => (x) => {
    const y = clone(x);
    y.set(k, v);
    return y;
};
