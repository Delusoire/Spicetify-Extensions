"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unlessM = exports.whenM = exports.nonePassM = exports.anyPassM = exports.allPassM = exports.orM = exports.andM = exports.ifM = void 0;
const function_1 = require("fp-ts/function");
const A = require("fp-ts/Array");
const Boolean_1 = require("./Boolean");
function ifM(M) {
    return p => x => y => M.chain(p, b => (b ? x : y));
}
exports.ifM = ifM;
function andM(M) {
    return x => y => M.chain(x, b => (b ? y : M.of(false)));
}
exports.andM = andM;
function orM(M) {
    return x => y => M.chain(x, b => (b ? M.of(true) : y));
}
exports.orM = orM;
function allPassM(M) {
    return fs => x => (0, function_1.pipe)(fs, A.reduce(M.of(true), (m, f) => M.chain(m, b => (b ? f(x) : M.of(false)))));
}
exports.allPassM = allPassM;
function anyPassM(M) {
    return fs => x => (0, function_1.pipe)(fs, A.reduce(M.of(false), (m, f) => M.chain(m, b => (b ? M.of(true) : f(x)))));
}
exports.anyPassM = anyPassM;
function nonePassM(M) {
    return fs => x => (0, function_1.pipe)(fs, A.reduce(M.of(true), (m, f) => M.chain(m, b => (b ? M.map(f(x), Boolean_1.invert) : M.of(false)))));
}
exports.nonePassM = nonePassM;
function whenM(M) {
    return b => x => M.chain(b, bb => (bb ? x : M.of(undefined)));
}
exports.whenM = whenM;
function unlessM(M) {
    return b => x => M.chain(b, bb => (bb ? M.of(undefined) : x));
}
exports.unlessM = unlessM;
