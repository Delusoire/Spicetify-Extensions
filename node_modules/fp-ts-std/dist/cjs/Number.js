"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.digits = exports.EnumInt = exports.BoundedSafe = exports.isNonPositive = exports.isNonNegative = exports.isNegative = exports.isPositive = exports.toFinite = exports.isFinite = exports.negate = exports.mod = exports.rem = exports.divide = exports.subtract = exports.multiply = exports.add = exports.decrement = exports.increment = exports.floatFromString = exports.fromString = exports.fromStringWithRadix = exports.isValid = void 0;
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const O = require("fp-ts/Option");
const Function_1 = require("./Function");
const number_1 = require("fp-ts/number");
const A = require("fp-ts/Array");
const L = require("./Lazy");
exports.isValid = (0, Predicate_1.not)(Number.isNaN);
const fromStringWithRadix = (radix) => (string) => (0, function_1.pipe)(Number.parseInt(string, radix), O.fromPredicate(exports.isValid));
exports.fromStringWithRadix = fromStringWithRadix;
exports.fromString = (0, exports.fromStringWithRadix)(10);
exports.floatFromString = (0, function_1.flow)(Number.parseFloat, O.fromPredicate(exports.isValid));
const increment = x => x + 1;
exports.increment = increment;
const decrement = x => x - 1;
exports.decrement = decrement;
const add = (x) => y => x + y;
exports.add = add;
const multiply = (x) => y => x * y;
exports.multiply = multiply;
const subtract = (subtrahend) => minuend => minuend - subtrahend;
exports.subtract = subtract;
const divide = (divisor) => dividend => dividend / divisor;
exports.divide = divide;
const rem = (divisor) => dividend => dividend % divisor;
exports.rem = rem;
const mod = (divisor) => dividend => ((dividend % divisor) + divisor) % divisor;
exports.mod = mod;
const negate = n => -n;
exports.negate = negate;
const isFinite = n => Math.abs(n) !== Infinity;
exports.isFinite = isFinite;
exports.toFinite = (0, Function_1.unless)(exports.isFinite)(n => Math.sign(n) * Number.MAX_SAFE_INTEGER);
const isPositive = n => Math.sign(n) === 1;
exports.isPositive = isPositive;
const isNegative = n => Math.sign(n) === -1;
exports.isNegative = isNegative;
const isNonNegative = n => Math.sign(n) !== -1;
exports.isNonNegative = isNonNegative;
const isNonPositive = n => Math.sign(n) !== 1;
exports.isNonPositive = isNonPositive;
exports.BoundedSafe = {
    ...number_1.Bounded,
    top: Number.MAX_SAFE_INTEGER,
    bottom: Number.MIN_SAFE_INTEGER,
};
exports.EnumInt = {
    ...exports.BoundedSafe,
    succ: (0, function_1.flow)(O.fromPredicate((0, Predicate_1.and)((n) => n < Number.MAX_SAFE_INTEGER)(Number.isInteger)), O.map(exports.increment)),
    pred: (0, function_1.flow)(O.fromPredicate((0, Predicate_1.and)((n) => n > Number.MIN_SAFE_INTEGER)(Number.isInteger)), O.map(exports.decrement)),
    toEnum: O.some,
    fromEnum: function_1.identity,
    cardinality: L.of(Infinity),
};
const digits = (n) => (0, function_1.pipe)([...(n + "")], A.filterMap(exports.fromString));
exports.digits = digits;
