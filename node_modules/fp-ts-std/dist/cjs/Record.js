"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.omit = exports.pick = exports.invertAll = exports.invertLast = exports.reject = exports.lookupV = exports.values = void 0;
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const R = require("fp-ts/Record");
const A = require("fp-ts/Array");
const T = require("fp-ts/Tuple");
const Semigroup_1 = require("fp-ts/Semigroup");
const Array_1 = require("./Array");
const Str = require("fp-ts/string");
exports.values = Object.values;
const lookupV = (x) => (k) => R.lookup(k)(x);
exports.lookupV = lookupV;
const reject = (f) => R.filter((0, Predicate_1.not)(f));
exports.reject = reject;
const invertLast = (f) => (0, function_1.flow)(R.toArray, A.map((0, function_1.flow)(T.mapSnd(f), T.swap)), R.fromFoldable((0, Semigroup_1.last)(), A.Foldable));
exports.invertLast = invertLast;
const invertAll = (f) => (0, function_1.flow)(R.toArray, A.map((0, function_1.flow)(T.bimap(f, A.of), T.swap)), R.fromFoldable(A.getMonoid(), A.Foldable));
exports.invertAll = invertAll;
const pick = (ks) => R.filterWithIndex((0, Array_1.elemV)(Str.Eq)(ks));
exports.pick = pick;
const omit = (ks) => R.filterWithIndex((0, Predicate_1.not)((0, Array_1.elemV)(Str.Eq)(ks)));
exports.omit = omit;
