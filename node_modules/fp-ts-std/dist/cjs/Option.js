"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.match2 = exports.getEnum = exports.getBounded = exports.altAllBy = exports.pureIf = exports.memptyUnless = exports.memptyWhen = exports.toMonoid = exports.invert = exports.noneAs = exports.unsafeUnwrap = exports.unsafeExpect = void 0;
const O = require("fp-ts/Option");
const function_1 = require("fp-ts/function");
const B = require("fp-ts/boolean");
const Boolean_1 = require("./Boolean");
const Alternative_1 = require("./Alternative");
const Monoid_1 = require("./Monoid");
const L = require("./Lazy");
const Number_1 = require("./Number");
const unsafeExpect = (msg) => (x) => {
    if (O.isNone(x))
        throw Error("Unwrapped `None`", { cause: msg });
    return x.value;
};
exports.unsafeExpect = unsafeExpect;
const unsafeUnwrap = (x) => {
    if (O.isNone(x))
        throw Error("Unwrapped `None`");
    return x.value;
};
exports.unsafeUnwrap = unsafeUnwrap;
const noneAs = () => O.none;
exports.noneAs = noneAs;
const invert = (eq) => (val) => (0, function_1.flow)(O.exists(x => eq.equals(x, val)), B.match(() => O.some(val), (0, function_1.constant)(O.none)));
exports.invert = invert;
exports.toMonoid = (0, Monoid_1.toMonoid)(O.Foldable);
const memptyWhen = (x) => (m) => x ? O.none : m();
exports.memptyWhen = memptyWhen;
exports.memptyUnless = (0, function_1.flow)(Boolean_1.invert, exports.memptyWhen);
exports.pureIf = (0, Alternative_1.pureIf)(O.Alternative);
exports.altAllBy = (0, Alternative_1.altAllBy)(O.Alternative);
const getBounded = (B) => ({
    ...O.getOrd(B),
    top: O.some(B.top),
    bottom: O.none,
});
exports.getBounded = getBounded;
const getEnum = (E) => ({
    ...(0, exports.getBounded)(E),
    succ: O.match(L.lazy(() => O.some(O.some(E.bottom))), (0, function_1.flow)(E.succ, O.map(O.some))),
    pred: O.map(E.pred),
    toEnum: n => n === 0 ? O.some(O.none) : (0, function_1.pipe)(n, Number_1.decrement, E.toEnum, O.map(O.some)),
    fromEnum: O.match((0, function_1.constant)(0), (0, function_1.flow)(E.fromEnum, Number_1.increment)),
    cardinality: (0, function_1.pipe)(E.cardinality, L.map(Number_1.increment)),
});
exports.getEnum = getEnum;
const match2 = (onNone, onSomeFst, onSomeSnd, onSomeBoth) => (mx) => (my) => (0, function_1.pipe)(mx, O.match(L.lazy(() => (0, function_1.pipe)(my, O.match(onNone, onSomeSnd))), x => (0, function_1.pipe)(my, O.match(L.lazy(() => onSomeFst(x)), y => onSomeBoth(x)(y)))));
exports.match2 = match2;
