"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwords = exports.words = exports.isSpace = exports.isUpper = exports.isLower = exports.isAlphaNum = exports.isAlpha = exports.splitAt = exports.takeRightWhile = exports.takeLeftWhile = exports.lookup = exports.init = exports.last = exports.tail = exports.head = exports.dropRightWhile = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.replaceAll = exports.test = exports.unlines = exports.lines = exports.reverse = exports.under = exports.matchAll = exports.match = exports.takeRight = exports.takeLeft = exports.unsurround = exports.surround = exports.unappend = exports.append = exports.unprepend = exports.prepend = exports.fromNumber = void 0;
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const O = require("fp-ts/Option");
const NEA = require("fp-ts/NonEmptyArray");
const RA = require("fp-ts/ReadonlyArray");
const S = require("fp-ts/string");
const ReadonlyArray_1 = require("./ReadonlyArray");
const Ord_1 = require("fp-ts/Ord");
const number_1 = require("fp-ts/number");
const Function_1 = require("./Function");
exports.fromNumber = String;
const prepend = (prepended) => rest => prepended + rest;
exports.prepend = prepend;
const unprepend = (start) => (0, Function_1.when)(S.startsWith(start))((0, exports.dropLeft)(start.length));
exports.unprepend = unprepend;
exports.append = (0, function_1.flip)(exports.prepend);
const unappend = (end) => (0, Function_1.when)(S.endsWith(end))((0, exports.dropRight)(end.length));
exports.unappend = unappend;
const surround = (x) => (0, function_1.flow)((0, exports.prepend)(x), (0, exports.append)(x));
exports.surround = surround;
const unsurround = (x) => (0, Function_1.when)((0, Predicate_1.and)(S.startsWith(x))(S.endsWith(x)))((0, function_1.flow)((0, exports.unprepend)(x), (0, exports.unappend)(x)));
exports.unsurround = unsurround;
const takeLeft = (n) => S.slice(0, (0, Ord_1.max)(number_1.Ord)(0, n));
exports.takeLeft = takeLeft;
const takeRight = (n) => x => S.slice((0, Ord_1.max)(number_1.Ord)(0, x.length - Math.floor(n)), Infinity)(x);
exports.takeRight = takeRight;
const match = (r) => (0, function_1.flow)((0, Function_1.invoke)("match")([r]), O.fromNullable);
exports.match = match;
const matchAll = (r) => (x) => (0, function_1.pipe)(O.tryCatch(() => x.matchAll(r)), O.chain((0, function_1.flow)(xs => Array.from(xs), NEA.fromArray)));
exports.matchAll = matchAll;
const under = (f) => (0, function_1.flow)(S.split(""), f, (0, ReadonlyArray_1.join)(""));
exports.under = under;
exports.reverse = (0, exports.under)(RA.reverse);
exports.lines = S.split(/\r\n|\r|\n/);
exports.unlines = (0, ReadonlyArray_1.join)("\n");
const test = (r) => x => {
    const lastIndex = r.lastIndex;
    const res = r.test(x);
    r.lastIndex = lastIndex;
    return res;
};
exports.test = test;
const replaceAll = (r) => (s) => (0, Function_1.invoke)("replace")([new RegExp(r, "g"), s]);
exports.replaceAll = replaceAll;
const dropLeft = (n) => (0, Function_1.invoke)("substring")([n]);
exports.dropLeft = dropLeft;
const dropRight = (n) => x => (0, function_1.pipe)(x, (0, Function_1.invoke)("substring")([0, x.length - Math.floor(n)]));
exports.dropRight = dropRight;
const dropLeftWhile = (f) => (0, function_1.pipe)(RA.dropLeftWhile(f), exports.under);
exports.dropLeftWhile = dropLeftWhile;
exports.dropRightWhile = (0, function_1.flow)(ReadonlyArray_1.dropRightWhile, exports.under);
exports.head = (0, function_1.flow)(O.fromPredicate((0, Predicate_1.not)(S.isEmpty)), O.map((0, exports.takeLeft)(1)));
exports.tail = (0, function_1.flow)(O.fromPredicate((0, Predicate_1.not)(S.isEmpty)), O.map((0, exports.dropLeft)(1)));
exports.last = (0, function_1.flow)(O.fromPredicate((0, Predicate_1.not)(S.isEmpty)), O.map((0, exports.takeRight)(1)));
exports.init = (0, function_1.flow)(O.fromPredicate((0, Predicate_1.not)(S.isEmpty)), O.map((0, exports.dropRight)(1)));
const lookup = (i) => (x) => (0, function_1.pipe)(x[i], O.fromNullable);
exports.lookup = lookup;
exports.takeLeftWhile = (0, function_1.flow)(f => RA.takeLeftWhile(f), exports.under);
exports.takeRightWhile = (0, function_1.flow)(ReadonlyArray_1.takeRightWhile, exports.under);
const splitAt = (index) => (str) => [S.slice(0, index)(str), S.slice(index, Infinity)(str)];
exports.splitAt = splitAt;
exports.isAlpha = (0, exports.test)(/^\p{Alpha}+$/u);
exports.isAlphaNum = (0, exports.test)(/^(\p{Alpha}|\p{Number})+$/u);
exports.isLower = (0, exports.test)(/^\p{Lower}+$/u);
exports.isUpper = (0, exports.test)(/^\p{Upper}+$/u);
exports.isSpace = (0, exports.test)(/^\s+$/);
exports.words = S.split(/\s/);
exports.unwords = (0, ReadonlyArray_1.join)(" ");
