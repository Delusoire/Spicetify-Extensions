"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoize = exports.lazy = exports.execute = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.let = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.ChainRec = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.flatten = exports.flatMap = exports.chain = exports.of = exports.ap = exports.map = exports.URI = void 0;
const function_1 = require("fp-ts/function");
const Functor_1 = require("fp-ts/Functor");
const Apply_1 = require("fp-ts/Apply");
const Chain_1 = require("fp-ts/Chain");
const RNEA = require("fp-ts/ReadonlyNonEmptyArray");
const RA = require("fp-ts/ReadonlyArray");
exports.URI = "Lazy";
const _map = (f, g) => () => g(f());
const _ap = (f, g) => () => f()(g());
const _chain = (f, g) => g(f());
const _chainRec = (a, f) => () => {
    let e = f(a)();
    while (e._tag === "Left") {
        e = f(e.left)();
    }
    return e.right;
};
const map = (f) => (fa) => _map(fa, f);
exports.map = map;
const ap = fa => fab => _ap(fab, fa);
exports.ap = ap;
exports.of = function_1.constant;
const chain = f => ma => _chain(ma, f);
exports.chain = chain;
exports.flatMap = exports.chain;
exports.flatten = (0, exports.chain)(function_1.identity);
exports.Functor = {
    URI: exports.URI,
    map: _map,
};
exports.flap = (0, Functor_1.flap)(exports.Functor);
exports.Pointed = {
    URI: exports.URI,
    of: exports.of,
};
exports.Apply = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
};
exports.apFirst = (0, Apply_1.apFirst)(exports.Apply);
exports.apSecond = (0, Apply_1.apSecond)(exports.Apply);
exports.Applicative = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    of: exports.of,
};
exports.Chain = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    chain: _chain,
};
exports.Monad = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    of: exports.of,
    chain: _chain,
};
exports.chainFirst = (0, Chain_1.chainFirst)(exports.Chain);
exports.ChainRec = {
    URI: exports.URI,
    map: _map,
    ap: _ap,
    chain: _chain,
    chainRec: _chainRec,
};
exports.Do = (0, exports.of)({});
exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
exports.bind = (0, Chain_1.bind)(exports.Chain);
exports.apS = (0, Apply_1.apS)(exports.Apply);
const let_ = (0, Functor_1.let)(exports.Functor);
exports.let = let_;
exports.ApT = (0, exports.of)([]);
const traverseReadonlyNonEmptyArrayWithIndex = (f) => (as) => () => {
    const out = [f(0, RNEA.head(as))()];
    for (let i = 1; i < as.length; i++) {
        out.push(f(i, as[i])());
    }
    return out;
};
exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
const traverseReadonlyArrayWithIndex = (f) => {
    const g = (0, exports.traverseReadonlyNonEmptyArrayWithIndex)(f);
    return as => (RA.isNonEmpty(as) ? g(as) : exports.ApT);
};
exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex;
const traverseArray = (f) => (0, exports.traverseReadonlyArrayWithIndex)((_, a) => f(a));
exports.traverseArray = traverseArray;
exports.sequenceArray = (0, exports.traverseArray)(function_1.identity);
const execute = (x) => x();
exports.execute = execute;
exports.lazy = function_1.identity;
const memoize = (f) => {
    const empty = Symbol();
    let res = empty;
    return () => (res === empty ? (res = f()) : res);
};
exports.memoize = memoize;
