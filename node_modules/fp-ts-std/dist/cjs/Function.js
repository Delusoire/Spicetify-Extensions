"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyN = exports.applySomes = exports.applyEvery = exports.isInstanceOf = exports.converge = exports.fork = exports.uncurry5 = exports.uncurry4 = exports.uncurry3 = exports.uncurry2 = exports.curry5 = exports.curry5T = exports.curry4 = exports.curry4T = exports.curry3 = exports.curry3T = exports.curry2 = exports.curry2T = exports.memoize = exports.invokeOn = exports.invokeNullary = exports.invoke = exports.construct = exports.until = exports.when = exports.unless = exports.ifElse = exports.guard = exports.unary = exports.withIndex = exports.let = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.Monad = exports.flatMap = exports.chain = exports.apSecond = exports.apFirst = exports.Applicative = exports.ap = exports.of = exports.Functor = exports.map = exports.URI = void 0;
const O = require("fp-ts/Option");
const M = require("fp-ts/Map");
const A = require("fp-ts/Array");
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const Endomorphism_1 = require("fp-ts/Endomorphism");
const Monoid_1 = require("fp-ts/Monoid");
const Semigroup_1 = require("fp-ts/Semigroup");
const Functor_1 = require("fp-ts/Functor");
const Apply_1 = require("fp-ts/Apply");
const Chain_1 = require("fp-ts/Chain");
exports.URI = "Function";
const map = f => g => (0, function_1.flow)(g, f);
exports.map = map;
exports.Functor = {
    URI: exports.URI,
    map: (f, g) => (0, exports.map)(g)(f),
};
exports.of = function_1.constant;
const ap = f => g => x => g(x)(f(x));
exports.ap = ap;
exports.Applicative = {
    ...exports.Functor,
    of: exports.of,
    ap: (f, g) => (0, exports.ap)(g)(f),
};
exports.apFirst = (0, Apply_1.apFirst)(exports.Applicative);
exports.apSecond = (0, Apply_1.apSecond)(exports.Applicative);
const chain = f => g => x => f(g(x))(x);
exports.chain = chain;
exports.flatMap = exports.chain;
exports.Monad = {
    ...exports.Applicative,
    chain: (f, g) => (0, exports.chain)(g)(f),
};
exports.Do = (0, exports.of)({});
exports.bindTo = (0, Functor_1.bindTo)(exports.Functor);
exports.bind = (0, Chain_1.bind)(exports.Monad);
exports.apS = (0, Apply_1.apS)(exports.Applicative);
const let_ = (0, Functor_1.let)(exports.Functor);
exports.let = let_;
const withIndex = f => g => xs => {
    let i = 0;
    return f(y => g(i++)(y))(xs);
};
exports.withIndex = withIndex;
exports.unary = function_1.tupled;
const guard = (branches) => (fallback) => (input) => (0, function_1.pipe)(branches, A.map(([f, g]) => (0, function_1.flow)(O.fromPredicate(f), O.map(g))), (0, Monoid_1.concatAll)((0, function_1.getMonoid)(O.getMonoid((0, Semigroup_1.first)()))()), (0, function_1.apply)(input), O.getOrElse(() => fallback(input)));
exports.guard = guard;
const ifElse = (onTrue) => (onFalse) => (f) => (x) => f(x) ? onTrue(x) : onFalse(x);
exports.ifElse = ifElse;
const unless = (f) => (onFalse) => x => f(x) ? x : onFalse(x);
exports.unless = unless;
exports.when = (0, function_1.flow)(Predicate_1.not, exports.unless);
const until = (f) => (g) => {
    const h = x => (f(x) ? x : h(g(x)));
    return h;
};
exports.until = until;
const construct = (x) => (xs) => new x(...xs);
exports.construct = construct;
const invoke = (x) => (ys) => (z) => z[x](...ys);
exports.invoke = invoke;
exports.invokeNullary = (0, function_1.flip)(exports.invoke)([]);
const invokeOn = () => (x) => ys => z => z[x](...ys);
exports.invokeOn = invokeOn;
const memoize = (eq) => (f) => {
    const cache = new Map();
    return k => {
        const cached = M.lookup(eq)(k)(cache);
        if (O.isSome(cached))
            return cached.value;
        const val = f(k);
        cache.set(k, val);
        return val;
    };
};
exports.memoize = memoize;
const curry2T = (f) => (a) => (b) => f([a, b]);
exports.curry2T = curry2T;
exports.curry2 = (0, function_1.flow)(exports.unary, exports.curry2T);
const curry3T = (f) => (a) => (b) => (c) => f([a, b, c]);
exports.curry3T = curry3T;
exports.curry3 = (0, function_1.flow)(exports.unary, exports.curry3T);
const curry4T = (f) => (a) => (b) => (c) => (d) => f([a, b, c, d]);
exports.curry4T = curry4T;
exports.curry4 = (0, function_1.flow)(exports.unary, exports.curry4T);
const curry5T = (f) => (a) => (b) => (c) => (d) => (e) => f([a, b, c, d, e]);
exports.curry5T = curry5T;
exports.curry5 = (0, function_1.flow)(exports.unary, exports.curry5T);
const uncurry2 = (f) => ([a, b]) => f(a)(b);
exports.uncurry2 = uncurry2;
const uncurry3 = (f) => ([a, b, c]) => f(a)(b)(c);
exports.uncurry3 = uncurry3;
const uncurry4 = (f) => ([a, b, c, d]) => f(a)(b)(c)(d);
exports.uncurry4 = uncurry4;
const uncurry5 = (f) => ([a, b, c, d, e]) => f(a)(b)(c)(d)(e);
exports.uncurry5 = uncurry5;
function fork(fs) {
    return (x) => fs.map(f => f(x));
}
exports.fork = fork;
const converge = (f) => (gs) => (0, function_1.flow)(x => fork(gs)(x), f);
exports.converge = converge;
const isInstanceOf = (x) => (y) => y instanceof x;
exports.isInstanceOf = isInstanceOf;
exports.applyEvery = (0, Monoid_1.concatAll)((0, Endomorphism_1.getMonoid)());
const applySomes = (fs) => x => (0, function_1.pipe)(fs, A.reduce(x, (y, mf) => (0, function_1.pipe)(mf, O.match((0, function_1.constant)(y), (0, function_1.apply)(y)))));
exports.applySomes = applySomes;
const applyN = (n) => (f) => (0, function_1.pipe)(A.replicate(n, f), exports.applyEvery);
exports.applyN = applyN;
