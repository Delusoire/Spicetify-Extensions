"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.omit = exports.pick = exports.invertAll = exports.invertLast = exports.reject = exports.lookupV = exports.values = void 0;
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const RR = require("fp-ts/ReadonlyRecord");
const RA = require("fp-ts/ReadonlyArray");
const RT = require("fp-ts/ReadonlyTuple");
const Semigroup_1 = require("fp-ts/Semigroup");
const ReadonlyArray_1 = require("./ReadonlyArray");
const Str = require("fp-ts/string");
exports.values = Object.values;
const lookupV = (x) => (k) => RR.lookup(k)(x);
exports.lookupV = lookupV;
const reject = (f) => RR.filter((0, Predicate_1.not)(f));
exports.reject = reject;
const invertLast = (f) => (0, function_1.flow)(RR.toReadonlyArray, RA.map((0, function_1.flow)(RT.mapSnd(f), RT.swap)), RR.fromFoldable((0, Semigroup_1.last)(), RA.Foldable));
exports.invertLast = invertLast;
const invertAll = (f) => (0, function_1.flow)(RR.toReadonlyArray, RA.map((0, function_1.flow)(RT.bimap(f, RA.of), RT.swap)), RR.fromFoldable(RA.getMonoid(), RA.Foldable));
exports.invertAll = invertAll;
const pick = (ks) => RR.filterWithIndex((0, ReadonlyArray_1.elemV)(Str.Eq)(ks));
exports.pick = pick;
const omit = (ks) => RR.filterWithIndex((0, Predicate_1.not)((0, ReadonlyArray_1.elemV)(Str.Eq)(ks)));
exports.omit = omit;
