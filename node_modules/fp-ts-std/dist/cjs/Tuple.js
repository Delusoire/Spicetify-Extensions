"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnum = exports.getBounded = exports.getOrd = exports.getEq = exports.fanout = exports.mapBoth = exports.create = exports.withSnd = exports.withFst = exports.traverseToSnd = exports.traverseToFst = exports.toSnd = exports.toFst = exports.dup = void 0;
const Tuple = require("fp-ts/Tuple");
const Function_1 = require("./Function");
const function_1 = require("fp-ts/function");
const Bifunctor_1 = require("./Bifunctor");
const Eq_1 = require("fp-ts/Eq");
const Ord_1 = require("fp-ts/Ord");
const Ordering_1 = require("./Ordering");
const L = require("./Lazy");
const Number_1 = require("./Number");
const O = require("fp-ts/Option");
const Predicate_1 = require("./Predicate");
exports.dup = (0, Function_1.fork)([function_1.identity, function_1.identity]);
const toFst = (f) => (0, Function_1.fork)([f, function_1.identity]);
exports.toFst = toFst;
const toSnd = (f) => (0, Function_1.fork)([function_1.identity, f]);
exports.toSnd = toSnd;
function traverseToFst(F) {
    return g => x => F.map(g(x), y => [y, x]);
}
exports.traverseToFst = traverseToFst;
function traverseToSnd(F) {
    return g => x => F.map(g(x), y => [x, y]);
}
exports.traverseToSnd = traverseToSnd;
const withFst = (x) => (y) => [x, y];
exports.withFst = withFst;
const withSnd = (x) => (y) => [y, x];
exports.withSnd = withSnd;
exports.create = function_1.identity;
exports.mapBoth = (0, Bifunctor_1.mapBoth)(Tuple.Bifunctor);
const fanout = f => g => (0, Function_1.fork)([f, g]);
exports.fanout = fanout;
const getEq = (EA) => (EB) => (0, Eq_1.fromEquals)(([xa, xb], [ya, yb]) => EA.equals(xa, ya) && EB.equals(xb, yb));
exports.getEq = getEq;
const getOrd = (OA) => (OB) => (0, Ord_1.fromCompare)(([xa, xb], [ya, yb]) => {
    const a = OA.compare(xa, ya);
    return a === Ordering_1.EQ ? OB.compare(xb, yb) : a;
});
exports.getOrd = getOrd;
const getBounded = (BA) => (BB) => ({
    ...(0, exports.getOrd)(BA)(BB),
    top: [BA.top, BB.top],
    bottom: [BA.bottom, BB.bottom],
});
exports.getBounded = getBounded;
const getEnum = (EA) => (EB) => ({
    ...(0, exports.getBounded)(EA)(EB),
    succ: ([a, b]) => EA.equals(a, EA.top)
        ? (0, function_1.pipe)(EB.succ(b), O.map((0, exports.withFst)(EA.bottom)))
        : (0, function_1.pipe)(EA.succ(a), O.map((0, exports.withSnd)(b))),
    pred: ([a, b]) => EA.equals(a, EA.bottom)
        ? (0, function_1.pipe)(EB.pred(b), O.map((0, exports.withFst)(EA.top)))
        : (0, function_1.pipe)(EA.pred(a), O.map((0, exports.withSnd)(b))),
    toEnum: (0, function_1.flow)(O.fromPredicate((0, Predicate_1.allPass)([Number_1.isValid, Number_1.isNonNegative, Number.isInteger])), O.chain(n => {
        const ac = L.execute(EA.cardinality);
        const bc = L.execute(EB.cardinality);
        if (n > ac + bc)
            return O.none;
        return (0, function_1.pipe)(O.of(exports.withFst), O.ap(EA.toEnum(n % ac)), O.ap(EB.toEnum(Math.floor(n / ac))));
    })),
    fromEnum: ([a, b]) => {
        const ai = EA.fromEnum(a);
        const bi = EB.fromEnum(b);
        const ac = L.execute(EA.cardinality);
        return (ac - 1) * bi + ai + bi;
    },
    cardinality: (0, function_1.pipe)(L.of(Number_1.multiply), L.ap(EA.cardinality), L.ap(EB.cardinality)),
});
exports.getEnum = getEnum;
