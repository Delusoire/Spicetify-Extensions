"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUnsafeConstantEnum = exports.inverseMap = exports.universe = exports.defaultCardinality = exports.downFromIncl = exports.downFromExcl = exports.upFromIncl = exports.upFromExcl = exports.fromThenTo = exports.fromTo = void 0;
const function_1 = require("fp-ts/function");
const O = require("fp-ts/Option");
const Option_1 = require("./Option");
const NEA = require("fp-ts/NonEmptyArray");
const A = require("fp-ts/Array");
const Tuple_1 = require("./Tuple");
const Map = require("fp-ts/Map");
const Semigroup = require("fp-ts/Semigroup");
const Number_1 = require("./Number");
const L = require("./Lazy");
const unfoldDup = (f) => (x) => A.unfold(x, (0, function_1.flow)(f, O.map(Tuple_1.dup)));
const unfoldDup1 = (f) => (x) => (0, function_1.pipe)(unfoldDup(f)(x), A.prepend(x));
const fromTo = (E) => (start) => (0, exports.fromThenTo)(E)(start)((0, function_1.pipe)(E.succ(start), O.getOrElse((0, function_1.constant)(start))));
exports.fromTo = fromTo;
const fromThenTo = (E) => (first) => (second) => (limit) => {
    const start = E.fromEnum(first);
    const step = E.fromEnum(second) - start;
    const end = E.fromEnum(limit);
    if (step < 1 || end < start)
        return NEA.of(first);
    const f = (0, function_1.flow)(O.fromPredicate(n => n <= end), O.map((0, Tuple_1.toSnd)((0, Number_1.add)(step))));
    return (0, function_1.pipe)(A.unfold(start, f), A.filterMap(E.toEnum), xs => xs);
};
exports.fromThenTo = fromThenTo;
const upFromExcl = (E) => unfoldDup(E.succ);
exports.upFromExcl = upFromExcl;
const upFromIncl = (E) => unfoldDup1(E.succ);
exports.upFromIncl = upFromIncl;
const downFromExcl = (E) => unfoldDup(E.pred);
exports.downFromExcl = downFromExcl;
const downFromIncl = (E) => unfoldDup1(E.pred);
exports.downFromIncl = downFromIncl;
const defaultCardinality = (E) => {
    const f = (n) => (0, function_1.flow)(E.succ, O.match((0, function_1.constant)(n), x => f(n + 1)(x)));
    return f(1)(E.bottom);
};
exports.defaultCardinality = defaultCardinality;
const universe = (E) => (0, exports.fromTo)(E)(E.bottom)(E.top);
exports.universe = universe;
const inverseMap = (E) => (Eq) => (f) => {
    const ys = (0, function_1.pipe)((0, exports.universe)(E), NEA.map((0, Tuple_1.toFst)(f)), Map.fromFoldable(Eq, Semigroup.last(), NEA.Foldable));
    return x => Map.lookup(Eq)(x)(ys);
};
exports.inverseMap = inverseMap;
const getUnsafeConstantEnum = (Ord) => (xs) => {
    const f = (y) => (0, function_1.pipe)(xs, A.findIndex(z => Ord.equals(y, z)));
    const g = (n) => A.lookup(n)(xs);
    const sorted = NEA.sort(Ord)(xs);
    const Bounded = {
        ...Ord,
        top: NEA.last(sorted),
        bottom: NEA.head(sorted),
    };
    return {
        ...Bounded,
        succ: (0, function_1.flow)(f, O.chain((0, function_1.flow)(Number_1.increment, g))),
        pred: (0, function_1.flow)(f, O.chain((0, function_1.flow)(Number_1.decrement, g))),
        toEnum: g,
        fromEnum: (0, function_1.flow)(f, (0, Option_1.unsafeExpect)("Failed to lookup fromEnum input via getUnsafeConstantEnum")),
        cardinality: L.of(xs.length),
    };
};
exports.getUnsafeConstantEnum = getUnsafeConstantEnum;
