"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.separateNE = exports.anyM = exports.allM = exports.fromIterable = exports.extractAt = exports.filterA = exports.zipAll = exports.maximum = exports.minimum = exports.reduceRightWhile = exports.reduceWhile = exports.symmetricDifference = exports.takeRightWhile = exports.transpose = exports.dropAt = exports.dropRightWhile = exports.countBy = exports.moveTo = exports.moveFrom = exports.reject = exports.slice = exports.aperture = exports.median = exports.mean = exports.product = exports.sum = exports.cartesian = exports.without = exports.endsWith = exports.startsWith = exports.dropRepeats = exports.insertMany = exports.upsert = exports.pluckFirst = exports.getDisorderedEq = exports.join = exports.none = exports.elemV = void 0;
const function_1 = require("fp-ts/function");
const Predicate_1 = require("fp-ts/Predicate");
const Ordering_1 = require("fp-ts/Ordering");
const number_1 = require("fp-ts/number");
const NEA = require("fp-ts/ReadonlyNonEmptyArray");
const Array_1 = require("fp-ts/Array");
const RA = require("fp-ts/ReadonlyArray");
const R = require("fp-ts/ReadonlyRecord");
const O = require("fp-ts/Option");
const B = require("fp-ts/boolean");
const Foldable_1 = require("fp-ts/Foldable");
const Monoid_1 = require("fp-ts/Monoid");
const Semigroup_1 = require("fp-ts/Semigroup");
const Function_1 = require("./Function");
const T = require("fp-ts/These");
const elemV = (eq) => (xs) => y => RA.elem(eq)(y)(xs);
exports.elemV = elemV;
exports.none = (0, function_1.flow)(Predicate_1.not, p => RA.every(p));
const join = (x) => (0, Function_1.invoke)("join")([x]);
exports.join = join;
const getDisorderedEq = (ordA) => ({
    equals: (xs, ys) => {
        const sort = RA.sort(ordA);
        return RA.getEq(ordA).equals(sort(xs), sort(ys));
    },
});
exports.getDisorderedEq = getDisorderedEq;
const pluckFirst = (p) => (xs) => (0, function_1.pipe)(RA.findIndex(p)(xs), O.fold((0, function_1.constant)([O.none, xs]), i => [
    O.some(xs[i]),
    RA.unsafeDeleteAt(i, xs),
]));
exports.pluckFirst = pluckFirst;
const upsert = (eqA) => (x) => (ys) => (0, function_1.pipe)(RA.findIndex(y => eqA.equals(x, y))(ys), O.map(i => RA.unsafeUpdateAt(i, x, ys)), O.chain(NEA.fromReadonlyArray), O.getOrElse(() => RA.append(x)(ys)));
exports.upsert = upsert;
const insertMany = (i) => (xs) => (ys) => (0, function_1.pipe)(xs, RA.reverse, (0, Foldable_1.reduceM)(O.Monad, RA.Foldable)(ys, (zs, x) => (0, function_1.pipe)(zs, RA.insertAt(i, x))), O.chain(NEA.fromReadonlyArray));
exports.insertMany = insertMany;
const dropRepeats = eq => xs => (0, function_1.pipe)(xs, RA.filterWithIndex((i, x) => i === 0 || !eq.equals(x, xs[i - 1])));
exports.dropRepeats = dropRepeats;
const startsWith = (eq) => (start) => (0, function_1.flow)(RA.takeLeft(start.length), xs => RA.getEq(eq).equals(xs, start));
exports.startsWith = startsWith;
const endsWith = (eq) => (end) => (0, function_1.flow)(RA.takeRight(end.length), xs => RA.getEq(eq).equals(xs, end));
exports.endsWith = endsWith;
const without = (eq) => (xs) => (0, function_1.flow)(RA.filter(y => !RA.elem(eq)(y)(xs)));
exports.without = without;
const cartesian = (xs) => (ys) => (0, function_1.pipe)(xs, RA.chain(x => (0, function_1.pipe)(ys, RA.map(y => [x, y]))));
exports.cartesian = cartesian;
exports.sum = (0, Monoid_1.concatAll)(number_1.MonoidSum);
exports.product = (0, Monoid_1.concatAll)(number_1.MonoidProduct);
const mean = (xs) => (0, exports.sum)(xs) / xs.length;
exports.mean = mean;
exports.median = (0, function_1.flow)(NEA.sort(number_1.Ord), xs => {
    const i = xs.length / 2;
    return i % 1 === 0 ? (xs[i - 1] + xs[i]) / 2 : xs[Math.floor(i)];
});
const aperture = (n) => (xs) => {
    const go = (i) => (ys) => i + n > xs.length ? ys : go(i + 1)(RA.append((0, exports.slice)(i)(n + i)(xs))(ys));
    return n < 1 ? [] : go(0)([]);
};
exports.aperture = aperture;
const slice = (start) => (end) => (0, Function_1.invoke)("slice")([start, end]);
exports.slice = slice;
const reject = (f) => RA.filter((0, Predicate_1.not)(f));
exports.reject = reject;
const moveFrom = (from) => (to) => (xs) => from >= xs.length || to >= xs.length
    ? O.none
    : from === to
        ? O.some(xs)
        : (0, function_1.pipe)(xs, RA.lookup(from), O.chain(x => (0, function_1.pipe)(RA.deleteAt(from)(xs), O.chain(RA.insertAt(to, x)))));
exports.moveFrom = moveFrom;
exports.moveTo = (0, function_1.flip)(exports.moveFrom);
const countBy = (f) => (xs) => R.fromFoldableMap(number_1.MonoidSum, RA.Foldable)(xs, x => [f(x), 1]);
exports.countBy = countBy;
const dropRightWhile = (f) => (0, function_1.flow)(RA.reverse, RA.dropLeftWhile(f), RA.reverse);
exports.dropRightWhile = dropRightWhile;
const dropAt = (i) => (n) => (xs) => (0, function_1.pipe)(RA.isOutOfBound(i, xs), B.fold(() => (0, function_1.pipe)((0, Array_1.copy)(Array.from(xs)), ys => {
    ys.splice(i, n);
    return ys;
}, O.some), (0, function_1.constant)(O.none)));
exports.dropAt = dropAt;
const transpose = (xs) => {
    if (RA.isEmpty(xs))
        return [];
    if (RA.isEmpty(xs[0]))
        return (0, exports.transpose)(RA.dropLeft(1)(xs));
    const [[y, ...ys], ...yss] = xs;
    const zs = [y, ...RA.filterMap(RA.head)(yss)];
    const zss = [ys, ...RA.map(RA.dropLeft(1))(yss)];
    return [zs, ...(0, exports.transpose)(zss)];
};
exports.transpose = transpose;
const takeRightWhile = (f) => (0, function_1.flow)(RA.reverse, RA.takeLeftWhile(f), RA.reverse);
exports.takeRightWhile = takeRightWhile;
const symmetricDifference = (eq) => (xs) => ys => RA.getMonoid().concat(RA.difference(eq)(ys)(xs), RA.difference(eq)(xs)(ys));
exports.symmetricDifference = symmetricDifference;
const reduceWhile = (p) => (f) => {
    const go = (acc) => (ys) => (0, function_1.pipe)(NEA.fromReadonlyArray(ys), O.filter((0, function_1.flow)(NEA.head, p)), O.fold((0, function_1.constant)(acc), (0, function_1.flow)(NEA.unprepend, ([z, zs]) => go(f(z)(acc))(zs))));
    return go;
};
exports.reduceWhile = reduceWhile;
const reduceRightWhile = (p) => (f) => (x) => (0, function_1.flow)(RA.reverse, (0, exports.reduceWhile)(p)(f)(x));
exports.reduceRightWhile = reduceRightWhile;
exports.minimum = (0, function_1.flow)(Semigroup_1.min, NEA.concatAll);
exports.maximum = (0, function_1.flow)(Semigroup_1.max, NEA.concatAll);
const zipAll = (xs) => (ys) => {
    const zs = RA.zip(ys, xs);
    const getRem = (0, exports.slice)(RA.size(zs))(Infinity);
    const rest = (0, function_1.pipe)(number_1.Ord.compare(RA.size(ys), RA.size(xs)), (0, Ordering_1.match)(() => (0, function_1.pipe)(xs, getRem, RA.map(T.right)), (0, function_1.constant)(RA.empty), () => (0, function_1.pipe)(ys, getRem, RA.map(T.left))));
    return (0, function_1.pipe)(zs, RA.map(([za, zb]) => T.both(za, zb)), RA.concat(rest));
};
exports.zipAll = zipAll;
function filterA(F) {
    return p => xs => RA.Witherable.wither(F)(xs, x => F.map(p(x), y => (y ? O.some(x) : O.none)));
}
exports.filterA = filterA;
const extractAt = (i) => (xs) => (0, function_1.pipe)(xs, RA.lookup(i), O.map(x => [x, RA.unsafeDeleteAt(i, xs)]));
exports.extractAt = extractAt;
exports.fromIterable = Array.from;
function allM(M) {
    return RA.reduce(M.of(true), (x, y) => M.chain(x, b => (b ? y : M.of(false))));
}
exports.allM = allM;
function anyM(M) {
    return RA.reduce(M.of(false), (x, y) => M.chain(x, b => (b ? M.of(true) : y)));
}
exports.anyM = anyM;
const separateNE = (xs) => (0, function_1.pipe)(xs, RA.separate, ({ left, right }) => {
    if (RA.isEmpty(left))
        return T.right(right);
    else if (RA.isEmpty(right))
        return T.left(left);
    else
        return T.both(left, right);
});
exports.separateNE = separateNE;
