"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnum = exports.getBounded = exports.getOrd = exports.match2 = exports.mapBoth = exports.unsafeExpectLeft = exports.unsafeExpect = exports.unsafeUnwrapLeft = exports.unsafeUnwrap = void 0;
const E = require("fp-ts/Either");
const O = require("fp-ts/Option");
const Bifunctor_1 = require("./Bifunctor");
const function_1 = require("fp-ts/function");
const L = require("./Lazy");
const Number_1 = require("./Number");
const Function_1 = require("./Function");
const Ordering_1 = require("./Ordering");
const unsafeUnwrap = (x) => {
    if (E.isLeft(x))
        throw Error("Unwrapped `Left`", { cause: x.left });
    return x.right;
};
exports.unsafeUnwrap = unsafeUnwrap;
const unsafeUnwrapLeft = (x) => {
    if (E.isRight(x))
        throw Error("Unwrapped `Right`", { cause: x.right });
    return x.left;
};
exports.unsafeUnwrapLeft = unsafeUnwrapLeft;
const unsafeExpect = (S) => (0, function_1.flow)(E.mapLeft(S.show), exports.unsafeUnwrap);
exports.unsafeExpect = unsafeExpect;
const unsafeExpectLeft = (S) => (0, function_1.flow)(E.map(S.show), exports.unsafeUnwrapLeft);
exports.unsafeExpectLeft = unsafeExpectLeft;
exports.mapBoth = (0, Bifunctor_1.mapBoth)(E.Bifunctor);
const match2 = (onLeftLeft, onLeftRight, onRightLeft, onRightRight) => (mab) => (mcd) => (0, function_1.pipe)(mab, E.match(a => (0, function_1.pipe)(mcd, E.match(c => onLeftLeft(a)(c), d => onLeftRight(a)(d))), b => (0, function_1.pipe)(mcd, E.match(c => onRightLeft(b)(c), d => onRightRight(b)(d)))));
exports.match2 = match2;
const getOrd = (EO) => (AO) => ({
    ...E.getEq(EO, AO),
    compare: (x, y) => (0, exports.match2)((0, Function_1.curry2)(EO.compare), (0, function_1.constant)((0, function_1.constant)(Ordering_1.LT)), (0, function_1.constant)((0, function_1.constant)(Ordering_1.GT)), (0, Function_1.curry2)(AO.compare))(x)(y),
});
exports.getOrd = getOrd;
const getBounded = (BE) => (BA) => ({
    ...(0, exports.getOrd)(BE)(BA),
    top: E.right(BA.top),
    bottom: E.left(BE.bottom),
});
exports.getBounded = getBounded;
const getEnum = (EE) => (EA) => ({
    ...(0, exports.getBounded)(EE)(EA),
    succ: E.match((0, function_1.flow)(EE.succ, O.matchW(L.lazy(() => E.right(EA.bottom)), E.left), O.some), (0, function_1.flow)(EA.succ, O.map(E.right))),
    pred: E.match((0, function_1.flow)(EE.pred, O.map(E.left)), (0, function_1.flow)(EA.pred, O.matchW(L.lazy(() => E.left(EE.top)), E.right), O.some)),
    toEnum: n => {
        const ec = L.execute(EE.cardinality);
        return n < ec
            ? (0, function_1.pipe)(n, EE.toEnum, O.map(E.left))
            : (0, function_1.pipe)(n - ec, EA.toEnum, O.map(E.right));
    },
    fromEnum: E.match(EE.fromEnum, (0, function_1.flow)(EA.fromEnum, n => n + L.execute(EE.cardinality))),
    cardinality: (0, function_1.pipe)(L.of(Number_1.add), L.ap(EE.cardinality), L.ap(EA.cardinality)),
});
exports.getEnum = getEnum;
