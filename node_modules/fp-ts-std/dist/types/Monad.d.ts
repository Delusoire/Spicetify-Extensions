/**
 * Utility functions to accommodate `fp-ts/Monad`.
 *
 * @since 0.15.0
 */
import { Kind, Kind2, Kind3, Kind4, URIS, URIS2, URIS3, URIS4 } from "fp-ts/HKT";
import { Monad1, Monad2, Monad2C, Monad3, Monad3C, Monad4 } from "fp-ts/Monad";
/**
 * Monadic if/then/else. Only executes the relevant action.
 *
 * @example
 * import { ifM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f =
 *   ifM(IO.Monad)(IO.of(true))
 *     (IO.of('foo'))(IO.of('bar'))
 *
 * assert.strictEqual(execute(f), 'foo')
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function ifM<M extends URIS4>(M: Monad4<M>): <S, R, E>(p: Kind4<M, S, R, E, boolean>) => <A>(x: Kind4<M, S, R, E, A>) => (y: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>;
export declare function ifM<M extends URIS3>(M: Monad3<M>): <R, E>(p: Kind3<M, R, E, boolean>) => <A>(x: Kind3<M, R, E, A>) => (y: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;
export declare function ifM<M extends URIS3, E>(M: Monad3C<M, E>): <R>(p: Kind3<M, R, E, boolean>) => <A>(x: Kind3<M, R, E, A>) => (y: Kind3<M, R, E, A>) => Kind3<M, R, E, A>;
export declare function ifM<M extends URIS2>(M: Monad2<M>): <E>(p: Kind2<M, E, boolean>) => <A>(x: Kind2<M, E, A>) => (y: Kind2<M, E, A>) => Kind2<M, E, A>;
export declare function ifM<M extends URIS2, E>(M: Monad2C<M, E>): (p: Kind2<M, E, boolean>) => <A>(x: Kind2<M, E, A>) => (y: Kind2<M, E, A>) => Kind2<M, E, A>;
export declare function ifM<M extends URIS>(M: Monad1<M>): (p: Kind<M, boolean>) => <A>(x: Kind<M, A>) => (y: Kind<M, A>) => Kind<M, A>;
/**
 * Monadic &&. Short-circuits.
 *
 * @example
 * import { andM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f = andM(IO.Monad)(IO.of(true))
 *
 * assert.strictEqual(execute(f(IO.of(true))), true)
 * assert.strictEqual(execute(f(IO.of(false))), false)
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function andM<M extends URIS4>(M: Monad4<M>): <S, R, E>(x: Kind4<M, S, R, E, boolean>) => (y: Kind4<M, S, R, E, boolean>) => Kind4<M, S, R, E, boolean>;
export declare function andM<M extends URIS3>(M: Monad3<M>): <R, E>(x: Kind3<M, R, E, boolean>) => (y: Kind3<M, R, E, boolean>) => Kind3<M, R, E, boolean>;
export declare function andM<M extends URIS3, E>(M: Monad3C<M, E>): <R>(x: Kind3<M, R, E, boolean>) => (y: Kind3<M, R, E, boolean>) => Kind3<M, R, E, boolean>;
export declare function andM<M extends URIS2>(M: Monad2<M>): <E>(x: Kind2<M, E, boolean>) => (y: Kind2<M, E, boolean>) => Kind2<M, E, boolean>;
export declare function andM<M extends URIS2, E>(M: Monad2C<M, E>): (x: Kind2<M, E, boolean>) => (y: Kind2<M, E, boolean>) => Kind2<M, E, boolean>;
export declare function andM<M extends URIS>(M: Monad1<M>): (x: Kind<M, boolean>) => (y: Kind<M, boolean>) => Kind<M, boolean>;
/**
 * Monadic ||. Short-circuits.
 *
 * @example
 * import { orM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f = orM(IO.Monad)(IO.of(false))
 *
 * assert.strictEqual(execute(f(IO.of(true))), true)
 * assert.strictEqual(execute(f(IO.of(false))), false)
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function orM<M extends URIS4>(M: Monad4<M>): <S, R, E>(x: Kind4<M, S, R, E, boolean>) => (y: Kind4<M, S, R, E, boolean>) => Kind4<M, S, R, E, boolean>;
export declare function orM<M extends URIS3>(M: Monad3<M>): <R, E>(x: Kind3<M, R, E, boolean>) => (y: Kind3<M, R, E, boolean>) => Kind3<M, R, E, boolean>;
export declare function orM<M extends URIS3, E>(M: Monad3C<M, E>): <R>(x: Kind3<M, R, E, boolean>) => (y: Kind3<M, R, E, boolean>) => Kind3<M, R, E, boolean>;
export declare function orM<M extends URIS2>(M: Monad2<M>): <E>(x: Kind2<M, E, boolean>) => (y: Kind2<M, E, boolean>) => Kind2<M, E, boolean>;
export declare function orM<M extends URIS2, E>(M: Monad2C<M, E>): (x: Kind2<M, E, boolean>) => (y: Kind2<M, E, boolean>) => Kind2<M, E, boolean>;
export declare function orM<M extends URIS>(M: Monad1<M>): (x: Kind<M, boolean>) => (y: Kind<M, boolean>) => Kind<M, boolean>;
/**
 * Monadic `allPass`. Short-circuits.
 *
 * @example
 * import { constant } from 'fp-ts/function'
 * import { allPassM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f = allPassM(IO.Monad)
 *
 * assert.strictEqual(execute(f([constant(IO.of(true)), constant(IO.of(true))])('foo')), true)
 * assert.strictEqual(execute(f([constant(IO.of(true)), constant(IO.of(false))])('foo')), false)
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function allPassM<M extends URIS4>(M: Monad4<M>): <S, R, E, A>(f: Array<(x: A) => Kind4<M, S, R, E, boolean>>) => (x: A) => Kind4<M, S, R, E, boolean>;
export declare function allPassM<M extends URIS3>(M: Monad3<M>): <R, E, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function allPassM<M extends URIS3, E>(M: Monad3C<M, E>): <R, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function allPassM<M extends URIS2>(M: Monad2<M>): <E, A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function allPassM<M extends URIS2, E>(M: Monad2C<M, E>): <A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function allPassM<M extends URIS>(M: Monad1<M>): <A>(f: Array<(x: A) => Kind<M, boolean>>) => (x: A) => Kind<M, boolean>;
/**
 * Monadic `anyPass`. Short-circuits.
 *
 * @example
 * import { constant } from 'fp-ts/function'
 * import { anyPassM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f = anyPassM(IO.Monad)
 *
 * assert.strictEqual(execute(f([constant(IO.of(true)), constant(IO.of(false))])('foo')), true)
 * assert.strictEqual(execute(f([constant(IO.of(false)), constant(IO.of(false))])('foo')), false)
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function anyPassM<M extends URIS4>(M: Monad4<M>): <S, R, E, A>(f: Array<(x: A) => Kind4<M, S, R, E, boolean>>) => (x: A) => Kind4<M, S, R, E, boolean>;
export declare function anyPassM<M extends URIS3>(M: Monad3<M>): <R, E, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function anyPassM<M extends URIS3, E>(M: Monad3C<M, E>): <R, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function anyPassM<M extends URIS2>(M: Monad2<M>): <E, A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function anyPassM<M extends URIS2, E>(M: Monad2C<M, E>): <A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function anyPassM<M extends URIS>(M: Monad1<M>): <A>(f: Array<(x: A) => Kind<M, boolean>>) => (x: A) => Kind<M, boolean>;
/**
 * Monadic `nonePass`. Short-circuits.
 *
 * @example
 * import { constant } from 'fp-ts/function'
 * import { nonePassM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import { execute } from 'fp-ts-std/IO'
 *
 * const f = nonePassM(IO.Monad)
 *
 * assert.strictEqual(execute(f([constant(IO.of(false)), constant(IO.of(false))])('foo')), true)
 * assert.strictEqual(execute(f([constant(IO.of(false)), constant(IO.of(true))])('foo')), false)
 *
 * @category 2 Typeclass Methods
 * @since 0.15.0
 */
export declare function nonePassM<M extends URIS4>(M: Monad4<M>): <S, R, E, A>(f: Array<(x: A) => Kind4<M, S, R, E, boolean>>) => (x: A) => Kind4<M, S, R, E, boolean>;
export declare function nonePassM<M extends URIS3>(M: Monad3<M>): <R, E, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function nonePassM<M extends URIS3, E>(M: Monad3C<M, E>): <R, A>(f: Array<(x: A) => Kind3<M, R, E, boolean>>) => (x: A) => Kind3<M, R, E, boolean>;
export declare function nonePassM<M extends URIS2>(M: Monad2<M>): <E, A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function nonePassM<M extends URIS2, E>(M: Monad2C<M, E>): <A>(f: Array<(x: A) => Kind2<M, E, boolean>>) => (x: A) => Kind2<M, E, boolean>;
export declare function nonePassM<M extends URIS>(M: Monad1<M>): <A>(f: Array<(x: A) => Kind<M, boolean>>) => (x: A) => Kind<M, boolean>;
/**
 * Like applicative `when`, but the condition is monadic.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import { whenM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import * as IOE from 'fp-ts/IOEither'
 * import { log } from 'fp-ts/Console'
 *
 * const isInvalid = (n: number): IO.IO<boolean> => () => Date.now() !== 42
 *
 * pipe(
 *   IOE.of(123),
 *   IOE.chainFirstIOK(n =>
 *     whenM(IO.Monad)(isInvalid(n))(log(n))),
 * )
 *
 * @category 2 Typeclass Methods
 * @since 0.16.0
 */
export declare function whenM<F extends URIS4>(M: Monad4<F>): <S, R, E>(b: Kind4<F, S, R, E, boolean>) => (x: Kind4<F, S, R, E, void>) => Kind4<F, S, R, E, void>;
export declare function whenM<F extends URIS3>(M: Monad3<F>): <R, E>(b: Kind3<F, R, E, boolean>) => (x: Kind3<F, R, E, void>) => Kind3<F, R, E, void>;
export declare function whenM<F extends URIS3, E>(M: Monad3C<F, E>): <R>(b: Kind3<F, R, E, boolean>) => (x: Kind3<F, R, E, void>) => Kind3<F, R, E, void>;
export declare function whenM<F extends URIS2>(M: Monad2<F>): <E>(b: Kind2<F, E, boolean>) => (x: Kind2<F, E, void>) => Kind2<F, E, void>;
export declare function whenM<F extends URIS2, E>(M: Monad2C<F, E>): (b: Kind2<F, E, boolean>) => (x: Kind2<F, E, void>) => Kind2<F, E, void>;
export declare function whenM<F extends URIS>(M: Monad1<F>): (b: Kind<F, boolean>) => (x: Kind<F, void>) => Kind<F, void>;
/**
 * The reverse of `whenM`.
 *
 * @example
 * import { pipe } from 'fp-ts/function'
 * import { unlessM } from 'fp-ts-std/Monad'
 * import * as IO from 'fp-ts/IO'
 * import * as IOE from 'fp-ts/IOEither'
 * import { log } from 'fp-ts/Console'
 *
 * const isValid = (n: number): IO.IO<boolean> => () => Date.now() === 42
 *
 * pipe(
 *   IOE.of(123),
 *   IOE.chainFirstIOK(n =>
 *     unlessM(IO.Monad)(isValid(n))(log(n))),
 * )
 *
 * @category 2 Typeclass Methods
 * @since 0.16.0
 */
export declare function unlessM<F extends URIS4>(M: Monad4<F>): <S, R, E>(b: Kind4<F, S, R, E, boolean>) => (x: Kind4<F, S, R, E, void>) => Kind4<F, S, R, E, void>;
export declare function unlessM<F extends URIS3>(M: Monad3<F>): <R, E>(b: Kind3<F, R, E, boolean>) => (x: Kind3<F, R, E, void>) => Kind3<F, R, E, void>;
export declare function unlessM<F extends URIS3, E>(M: Monad3C<F, E>): <R>(b: Kind3<F, R, E, boolean>) => (x: Kind3<F, R, E, void>) => Kind3<F, R, E, void>;
export declare function unlessM<F extends URIS2>(M: Monad2<F>): <E>(b: Kind2<F, E, boolean>) => (x: Kind2<F, E, void>) => Kind2<F, E, void>;
export declare function unlessM<F extends URIS2, E>(M: Monad2C<F, E>): (b: Kind2<F, E, boolean>) => (x: Kind2<F, E, void>) => Kind2<F, E, void>;
export declare function unlessM<F extends URIS>(M: Monad1<F>): (b: Kind<F, boolean>) => (x: Kind<F, void>) => Kind<F, void>;
//# sourceMappingURL=Monad.d.ts.map