/**
 * Whilst the definition of `Lazy` happens to be the same as `IO`, they
 * represent different intentions, specifically with respect to `Lazy`
 * representing a pure thunk.
 *
 * Thinking in terms of Haskell, `Lazy` can be considered equivalent to a pure
 * function that takes `()` (unit) as input.
 *
 * @since 0.12.0
 */
import { Functor1 } from "fp-ts/Functor";
import { Applicative1 } from "fp-ts/Applicative";
import { Monad1 } from "fp-ts/Monad";
import { Pointed1 } from "fp-ts/Pointed";
import { Apply1 } from "fp-ts/Apply";
import { Chain1 } from "fp-ts/Chain";
import { ChainRec1 } from "fp-ts/ChainRec";
import { ReadonlyNonEmptyArray } from "fp-ts/ReadonlyNonEmptyArray";
/**
 * Re-exported from fp-ts for convenience.
 *
 * @category 0 Types
 * @since 0.12.0
 */
export type Lazy<A> = () => A;
/**
 * Typeclass machinery.
 *
 * @category 4 Minutiae
 * @since 0.12.0
 */
export declare const URI = "Lazy";
/**
 * Typeclass machinery.
 *
 * @category 4 Minutiae
 * @since 0.12.0
 */
export type URI = typeof URI;
declare module "fp-ts/HKT" {
    interface URItoKind<A> {
        readonly [URI]: Lazy<A>;
    }
}
/**
 * Map the output of a `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const map: <A, B>(f: (x: A) => B) => (fa: Lazy<A>) => Lazy<B>;
/**
 * Apply a function within a `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const ap: <A>(fa: Lazy<A>) => <B>(fab: Lazy<(a: A) => B>) => Lazy<B>;
/**
 * Raise any value to a `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const of: Pointed1<URI>["of"];
/**
 * Map and flatten the output of a `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const chain: <A, B>(f: (a: A) => Lazy<B>) => (ma: Lazy<A>) => Lazy<B>;
/**
 * Alias of `chain`.
 *
 * @category 2 Typeclass Methods
 * @since 0.17.0
 */
export declare const flatMap: <A, B>(f: (a: A) => Lazy<B>) => (ma: Lazy<A>) => Lazy<B>;
/**
 * Flatten a nested `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const flatten: <A>(mma: Lazy<Lazy<A>>) => Lazy<A>;
/**
 * Formal `Functor` instance for `Lazy` to be provided to higher-kinded
 * functions that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Functor: Functor1<URI>;
/**
 * Takes a function in a functorial `Lazy` context and applies it to an
 * ordinary value.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const flap: <A>(a: A) => <B>(fab: Lazy<(a: A) => B>) => Lazy<B>;
/**
 * Formal `Pointed` instance for `Lazy` to be provided to higher-kinded
 * functions that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Pointed: Pointed1<URI>;
/**
 * Formal `Apply` instance for `Lazy` to be provided to higher-kinded functions
 * that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Apply: Apply1<URI>;
/**
 * Sequence actions, discarding the value of the first argument.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const apFirst: <B>(second: Lazy<B>) => <A>(first: Lazy<A>) => Lazy<A>;
/**
 * Sequence actions, discarding the value of the second argument.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const apSecond: <B>(second: Lazy<B>) => <A>(first: Lazy<A>) => Lazy<B>;
/**
 * Formal `Applicative` instance for `Lazy` to be provided to higher-kinded
 * functions that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Applicative: Applicative1<URI>;
/**
 * Formal `Chain` instance for `Lazy` to be provided to higher-kinded functions
 * that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Chain: Chain1<URI>;
/**
 * Formal `Monad` instance for `Lazy` to be provided to higher-kinded functions
 * that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const Monad: Monad1<URI>;
/**
 * Like `chain`, but discards the new output.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const chainFirst: <A, _>(f: (a: A) => Lazy<_>) => (first: Lazy<A>) => Lazy<A>;
/**
 * Formal `ChainRec` instance for `Lazy` to be provided to higher-kinded
 * functions that require it.
 *
 * @category 1 Typeclass Instances
 * @since 0.12.0
 */
export declare const ChainRec: ChainRec1<URI>;
/**
 * Initiate do notation in the context of `Lazy`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const Do: Lazy<{}>;
/**
 * Bind the provided value, typically preceding it in a pipeline, to the
 * specified key in do notation.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const bindTo: <N extends string>(name: N) => <A>(fa: Lazy<A>) => Lazy<{ readonly [K in N]: A; }>;
/**
 * Bind the output of the provided function to the specified key in do notation.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const bind: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => Lazy<B>) => (ma: Lazy<A>) => Lazy<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
/**
 * Bind the provided value to the specified key in do notation.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const apS: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: Lazy<B>) => (fa: Lazy<A>) => Lazy<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
declare const let_: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => B) => (fa: Lazy<A>) => Lazy<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
export { 
/**
 * Assign a variable in do notation.
 *
 * @category 2 Typeclass Methods
 * @since 0.17.0
 */
let_ as let, };
/**
 * Identity for `Lazy` as applied to `sequenceT`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const ApT: Lazy<readonly []>;
/**
 * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(Applicative)`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(f: (index: number, a: A) => Lazy<B>) => (as: ReadonlyNonEmptyArray<A>) => Lazy<ReadonlyNonEmptyArray<B>>;
/**
 * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const traverseReadonlyArrayWithIndex: <A, B>(f: (index: number, a: A) => Lazy<B>) => (as: readonly A[]) => Lazy<readonly B[]>;
/**
 * Equivalent to `Array#traverseWithIndex(Applicative)`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const traverseArrayWithIndex: <A, B>(f: (index: number, a: A) => Lazy<B>) => (as: ReadonlyArray<A>) => Lazy<ReadonlyArray<B>>;
/**
 * Equivalent to `Array#traverse(Applicative)`.
 *
 * @category 2 Typeclass Methods
 * @since 0.12.0
 */
export declare const traverseArray: <A, B>(f: (a: A) => Lazy<B>) => (as: readonly A[]) => Lazy<readonly B[]>;
/**
 * Equivalent to `Array#sequence(Applicative)`.
 *
 * @category 2 Typeclass Methods
 * @since 2.9.0
 */
export declare const sequenceArray: <A>(arr: ReadonlyArray<Lazy<A>>) => Lazy<ReadonlyArray<A>>;
/**
 * Execute a `Lazy`, returning the value within. Helpful for staying within
 * function application and composition pipelines.
 *
 * @example
 * import * as Lazy from 'fp-ts-std/Lazy'
 *
 * assert.strictEqual(Lazy.execute(Lazy.of(5)), 5)
 *
 * @category 3 Functions
 * @since 0.12.0
 */
export declare const execute: <A>(x: Lazy<A>) => A;
/**
 * A constructor for `Lazy` values. Given `Lazy` is a type alias around
 * `() => A`, this function's only purpose is to aid in readability and express
 * intentional laziness, as opposed to for example forgetting or opting not to
 * use `constant`.
 *
 * @example
 * import { lazy } from 'fp-ts-std/Lazy'
 *
 * const calc = lazy(() => 'do something expensive here')
 *
 * @category 3 Functions
 * @since 0.13.0
 */
export declare const lazy: <A>(f: () => A) => Lazy<A>;
/**
 * Memoize a `Lazy`. Provided the input function is pure, this function is too.
 *
 * @example
 * import { lazy, memoize } from 'fp-ts-std/Lazy'
 *
 * const expensive = lazy(() => 42)
 * const payOnce = memoize(expensive)
 *
 * assert.strictEqual(payOnce(), payOnce())
 *
 * @category 3 Functions
 * @since 0.14.0
 */
export declare const memoize: <A>(f: Lazy<A>) => Lazy<A>;
//# sourceMappingURL=Lazy.d.ts.map