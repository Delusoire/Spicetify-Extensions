/**
 * This module targets objects in the sense of product types. For objects in
 * the sense of maps see the `Record` module.
 *
 * @since 0.14.0
 */
/**
 * Merge two structs together. For merging many identical structs, instead
 * consider defining a semigroup.
 *
 * @example
 * import { merge } from 'fp-ts-std/Struct'
 *
 * assert.deepStrictEqual(merge({ a: 1, b: 2 })({ b: 'two', c: true }), { a: 1, b: 'two', c: true })
 *
 * @category 3 Functions
 * @since 0.14.0
 */
export declare const merge: <A, B>(x: A) => <C extends B>(y: C) => A & C;
/**
 * Pick a set of keys from a struct. The value-level equivalent of the `Pick`
 * type.
 *
 * @example
 * import { pick } from 'fp-ts-std/Struct'
 * import { pipe } from 'fp-ts/function'
 *
 * const picked = pipe(
 *   { a: 1, b: 'two', c: [true] },
 *   pick(['a', 'c'])
 * )
 *
 * assert.deepStrictEqual(picked, { a: 1, c: [true] })
 *
 * @category 3 Functions
 * @since 0.14.0
 */
export declare const pick: <A extends object, K extends keyof A>(ks: K[]) => (x: A) => Pick<A, K>;
/**
 * Like `pick`, but allows you to specify the input struct upfront.
 *
 * @example
 * import { pickFrom } from 'fp-ts-std/Struct'
 *
 * type MyType = { a: number; b: string; c: ReadonlyArray<boolean> }
 * const picked = pickFrom<MyType>()(['a', 'c'])
 *
 * assert.deepStrictEqual(picked({ a: 1, b: 'two', c: [true] }), { a: 1, c: [true] })
 *
 * @category 3 Functions
 * @since 0.14.0
 */
export declare const pickFrom: <A extends object>() => <K extends keyof A>(ks: K[]) => (x: A) => Pick<A, K>;
/**
 * Get the value for a key in a struct.
 *
 * @example
 * import { get } from 'fp-ts-std/Struct'
 *
 * type Person = { name: string; age: number }
 * const person: Person = { name: 'Albert', age: 76 }
 *
 * const getName = get('name')
 *
 * assert.strictEqual(getName(person), 'Albert')
 *
 * @category 3 Functions
 * @since 0.17.0
 */
export declare const get: <K extends string>(k: K) => <A>(x: Record<K, A>) => A;
/**
 * Omit a set of keys from a struct. The value-level equivalent of the `Omit`
 * type.
 *
 * @example
 * import { omit } from 'fp-ts-std/Struct'
 *
 * const sansB = omit(['b'])
 *
 * assert.deepStrictEqual(sansB({ a: 1, b: 'two', c: [true] }), { a: 1, c: [true] })
 *
 * @category 3 Functions
 * @since 0.14.0
 */
export declare const omit: <K extends string>(ks: K[]) => <V, A extends Record<K, V>>(x: A) => Omit<A, K>;
/**
 * Like `omit`, but allows you to specify the input struct upfront.
 *
 * @example
 * import { omitFrom } from 'fp-ts-std/Struct'
 *
 * type MyType = { a: number; b: string; c: ReadonlyArray<boolean> }
 * const sansB = omitFrom<MyType>()(['b'])
 *
 * assert.deepStrictEqual(sansB({ a: 1, b: 'two', c: [true] }), { a: 1, c: [true] })
 *
 * @category 3 Functions
 * @since 0.15.0
 */
export declare const omitFrom: <A>() => <K extends keyof A & string>(ks: K[]) => (x: A) => Omit<A, K>;
type OptionalKeys<O extends object> = {
    [K in keyof O]-?: Record<string, unknown> extends Pick<O, K> ? K : never;
}[keyof O];
type Exact<A extends object, B extends A> = A & Record<Exclude<keyof B, keyof A>, never>;
/**
 * Provide default values for an object with optional properties.
 *
 * @example
 * import { withDefaults } from 'fp-ts-std/Struct'
 * import { pipe } from 'fp-ts/function'
 *
 * const aOptB: { a: number; b?: string } = { a: 1 }
 *
 * assert.deepStrictEqual(pipe(aOptB, withDefaults({ b: 'foo' })), { a: 1, b: 'foo' })
 *
 * @category 3 Functions
 * @since 0.15.0
 */
export declare const withDefaults: <T extends object, PT extends Exact<{
    [K in OptionalKeys<T>]-?: Exclude<T[K], undefined>;
}, PT>>(defaults: PT) => (t: T) => PT & T;
type MaybePartial<A> = A | Partial<A>;
type RenameKey<A extends Record<string, unknown>, I extends keyof A, J extends string> = {
    [K in keyof A as K extends I ? J : K]: A[K];
};
/**
 * Rename a key in a struct, preserving the value. If the new key already
 * exists, the old key will be overwritten. Optionality is preserved.
 *
 * @example
 * import { renameKey } from 'fp-ts-std/Struct'
 *
 * type Foo = { a: string; b: number }
 * type Bar = { a: string; c: number }
 *
 * const fooBar: (x: Foo) => Bar = renameKey('b')('c')
 *
 * @category 3 Functions
 * @since 0.15.0
 */
export declare const renameKey: <I extends string>(oldK: I) => <J extends string>(newK: J) => <A extends MaybePartial<Record<I, unknown>>>(x: A) => RenameKey<A, I, J>;
export {};
//# sourceMappingURL=Struct.d.ts.map