{
  "version": 3,
  "sources": ["../../shared/deps.ts", "../../shared/util.ts", "../../shared/platformApi.ts", "../../extensions/sort-plus/settings.ts", "../../shared/settings.tsx", "../../shared/modules.ts", "../../shared/api.ts", "../../shared/GraphQL/fetchAlbum.ts", "../../shared/GraphQL/fetchArtistDiscography.ts", "../../shared/GraphQL/fetchArtistOveriew.ts", "../../shared/fp.ts", "../../shared/parse.ts", "../../extensions/sort-plus/fetch.ts", "../../extensions/sort-plus/util.ts", "../../extensions/sort-plus/playlistsInterop.ts", "../../extensions/sort-plus/populate.ts", "../../extensions/sort-plus/app.ts"],
  "sourcesContent": ["// @deno-types=\"npm:@types/lodash\"\r\nimport { default as ld } from \"https://esm.sh/lodash\"\r\nexport const _ = ld\r\n\r\n// @deno-types=\"npm:@types/lodash/fp\"\r\nimport { default as ld_fp } from \"https://esm.sh/lodash/fp\"\r\nexport const fp = ld_fp\r\n", "export type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nconst { Player, URI } = Spicetify\r\nconst { PlayerAPI, History } = Spicetify.Platform\r\n\r\nexport const SpotifyLoc = {\r\n    before: {\r\n        start: () => ({ before: \"start\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ before: { uri } }),\r\n        fromUid: (uid: string) => ({ before: { uid } }),\r\n    },\r\n    after: {\r\n        end: () => ({ after: \"end\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ after: { uri } }),\r\n        fromUid: (uid: string) => ({ after: { uid } }),\r\n    },\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E | null,\r\n) =>\r\n    new Promise((resolve: (value: Element) => void, reject) => {\r\n        const onMutation = () => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el) {\r\n                if (notEl && el === notEl) {\r\n                } else {\r\n                    observer.disconnect()\r\n                    return resolve(el)\r\n                }\r\n            }\r\n        }\r\n\r\n        const observer = new MutationObserver(onMutation)\r\n        onMutation()\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout)\r\n            setTimeout(() => {\r\n                observer.disconnect()\r\n                reject()\r\n            }, timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element] as any\r\n\r\nexport const createQueueItem =\r\n    (queued: boolean) =>\r\n    ({ uri, uid = \"\" }: { uri: string; uid?: string }) => ({\r\n        contextTrack: {\r\n            uri,\r\n            uid,\r\n            metadata: {\r\n                is_queued: queued.toString(),\r\n            },\r\n        },\r\n        removed: [],\r\n        blocked: [],\r\n        provider: queued ? (\"queue\" as const) : (\"context\" as const),\r\n    })\r\n\r\nexport const setQueue = async (\r\n    nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>,\r\n    contextUri?: string,\r\n) => {\r\n    const { _queue, _client } = PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    const res = await _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    })\r\n\r\n    await PlayerAPI.skipToNext()\r\n\r\n    if (contextUri) {\r\n        await new Promise<void>(resolve => {\r\n            PlayerAPI._events.addListener(\"queue_update\", () => resolve(), { once: true })\r\n        })\r\n        await setPlayingContext(contextUri)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nexport const setPlayingContext = (uri: string) => {\r\n    const { sessionId } = PlayerAPI._state\r\n    return PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri })\r\n}\r\n\r\nexport const onHistoryChanged = (\r\n    toMatchTo: string | RegExp | ((location: string) => boolean),\r\n    callback: (uri: SpotifyURI) => void,\r\n    dropDuplicates = true,\r\n) => {\r\n    const createMatchFn = (toMatchTo: string | RegExp | ((input: string) => boolean)) => {\r\n        switch (typeof toMatchTo) {\r\n            case \"string\":\r\n                return (input: string) => input?.startsWith(toMatchTo) ?? false\r\n\r\n            case \"function\":\r\n                return toMatchTo\r\n\r\n            default:\r\n                return (input: string) => toMatchTo.test(input)\r\n        }\r\n    }\r\n\r\n    let lastPathname = \"\"\r\n    const matchFn = createMatchFn(toMatchTo)\r\n\r\n    const historyChanged = ({ pathname }: any) => {\r\n        if (matchFn(pathname)) {\r\n            if (dropDuplicates && lastPathname === pathname) {\r\n            } else callback(URI.fromString(pathname).toURI())\r\n        }\r\n        lastPathname = pathname\r\n    }\r\n\r\n    historyChanged(History.location ?? {})\r\n    return History.listen(historyChanged)\r\n}\r\n\r\nexport const onSongChanged = (callback: (state?: Spicetify.PlayerState) => void) => {\r\n    callback(Player.data)\r\n    Player.addEventListener(\"songchange\", event => callback(event!.data))\r\n}\r\n", "import { SpotifyLoc, SpotifyURI } from \"./util.ts\"\r\n\r\nconst { CosmosAsync } = Spicetify\r\nconst { LibraryAPI, PlaylistAPI, RootlistAPI, PlaylistPermissionsAPI, EnhanceAPI, LocalFilesAPI } = Spicetify.Platform\r\n\r\nexport const areTracksLiked = (uris: SpotifyURI[]) => LibraryAPI.contains(...uris)\r\n\r\nexport const setTracksLiked = (uris: SpotifyURI[], liked: boolean) => LibraryAPI[liked ? \"add\" : \"remove\"]({ uris })\r\n\r\nexport const toggleTracksLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await areTracksLiked(uris)\r\n\r\n    const urisByLiked = Object.groupBy(uris, (_, index) => (liked[index] ? \"liked\" : \"notLiked\"))\r\n\r\n    const ps = []\r\n    urisByLiked.liked?.length && ps.push(setTracksLiked(urisByLiked.liked, false))\r\n    urisByLiked.notLiked?.length && ps.push(setTracksLiked(urisByLiked.notLiked, true))\r\n\r\n    return Promise.all(ps)\r\n}\r\n\r\nexport const fetchLikedTracks = async () =>\r\n    (\r\n        await LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items\r\nexport const fetchArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await LibraryAPI.getTracks({ uri, offset, limit })).items\r\n\r\nexport const fetchPlaylistContents = async (uri: SpotifyURI) => (await PlaylistAPI.getContents(uri)).items\r\n\r\nexport const createFolder = async (name: string, location: Spicetify.Platform.RootlistAPI.Location = {}) =>\r\n    await RootlistAPI.createFolder(name, location)\r\n\r\nexport const addPlaylist = async (playlist: SpotifyURI, folder?: SpotifyURI) =>\r\n    await RootlistAPI.add([playlist], folder ? SpotifyLoc.after.fromUri(folder) : {})\r\n\r\n/* Replaced by createPlaylistFromTracks */\r\nexport const createPlaylist = async (name: string, location: Spicetify.Platform.RootlistAPI.Location = {}) =>\r\n    await RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchFolder = async (folder?: SpotifyURI) => await RootlistAPI.getContents({ folderUri: folder })\r\nexport const fetchRootFolder = () => fetchFolder(undefined)\r\n\r\nexport const addPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: SpotifyURI[],\r\n    location: Spicetify.Platform.RootlistAPI.Location = {},\r\n) => await PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    uids: string[],\r\n    location: Spicetify.Platform.RootlistAPI.Location = {},\r\n) =>\r\n    await PlaylistAPI.move(\r\n        playlist,\r\n        uids.map(uid => ({ uid })),\r\n        location,\r\n    )\r\n\r\nexport const removePlaylistTracks = (playlist: SpotifyURI, tracks: Array<{ uid: string }>) =>\r\n    PlaylistAPI.remove(playlist, tracks)\r\n\r\nexport const fetchPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage.pageItems\r\nexport const fetchPlaylistEnhancedSongs = async (\r\n    uri: SpotifyURI,\r\n    offset = 0,\r\n): Promise<Array<Spicetify.Platform.EnhanceAPI.EnhanceItem>> => {\r\n    const nextPageItems = await fetchPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(await fetchPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await LocalFilesAPI.getTracks()\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\n\r\nimport { createFolder } from \"../../shared/platformApi.ts\"\r\nimport { SettingsSection } from \"../../shared/settings.tsx\"\r\nimport { SpotifyURI } from \"../../shared/util.ts\"\r\n\r\nconst SORTED_PLAYLISTS_FOLDER_NAME = \"Sorted Playlists\"\r\n\r\nconst settings = new SettingsSection(\"Sort Plus\")\r\n    .addToggle({ id: \"descending\", desc: \"Descending\" }, task.of(true))\r\n    .addToggle({ id: \"artistAllDiscography\", desc: \"All of the artist's Discography\" })\r\n    .addToggle({ id: \"artistTopTracks\", desc: \"Top Tracks\" }, task.of(true))\r\n    .addToggle({ id: \"artistPopularReleases\", desc: \"Popular Releases\" }, task.of(true))\r\n    .addToggle({ id: \"artistSingles\", desc: \"Singles\" })\r\n    .addToggle({ id: \"artistAlbums\", desc: \"Albums\" })\r\n    .addToggle({ id: \"artistCompilations\", desc: \"Compilations\" })\r\n    .addToggle({ id: \"artistLikedTracks\", desc: \"Liked Tracks\" }, task.of(true))\r\n    .addToggle({ id: \"artistAppearsOn\", desc: \"Appears On\" }, task.of(false))\r\n    .addInput({ id: \"lastFmUsername\", desc: \"Last.fm Username\", inputType: \"text\" }, task.of(\"Username\"))\r\n    .addInput(\r\n        { id: \"LFMApiKey\", desc: \"Last.fm API Key\", inputType: \"text\" },\r\n        task.of(\"********************************\"),\r\n    )\r\n    .addInput(\r\n        {\r\n            id: \"sortedPlaylistsFolderUri\",\r\n            desc: \"Sorted Playlists folder uri\",\r\n            inputType: \"text\",\r\n        },\r\n        async () => (await createFolder(SORTED_PLAYLISTS_FOLDER_NAME)).uri,\r\n    )\r\n\r\nsettings.pushSettings()\r\n\r\nexport const CONFIG = settings.toObject() as {\r\n    artistAllDiscography: boolean\r\n    artistTopTracks: boolean\r\n    artistPopularReleases: boolean\r\n    artistSingles: boolean\r\n    artistAlbums: boolean\r\n    artistCompilations: boolean\r\n    artistLikedTracks: boolean\r\n    artistAppearsOn: boolean\r\n    descending: boolean\r\n    lastFmUsername: string\r\n    LFMApiKey: string\r\n    sortedPlaylistsFolderUri: SpotifyURI\r\n}\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\nimport { SectionTitle, SettingColumn, SettingSection, SettingText, SettingToggle } from \"./modules.ts\"\r\nimport { sleep } from \"./util.ts\"\r\nimport { _ } from \"./deps.ts\"\r\n\r\nconst { React, ReactDOM, LocalStorage } = Spicetify\r\nconst { ButtonSecondary } = Spicetify.ReactComponent\r\nconst { History } = Spicetify.Platform\r\n\r\ntype FieldToProps<A> = Omit<A, \"type\">\r\n\r\nexport const enum FieldType {\r\n    BUTTON = \"button\",\r\n    TOGGLE = \"toggle\",\r\n    INPUT = \"input\",\r\n    HIDDEN = \"hidden\",\r\n}\r\n\r\nexport interface BaseField {\r\n    id: string\r\n    type: FieldType\r\n    desc: string\r\n}\r\n\r\nexport type SettingsField = HiddenField | InputField | ButtonField | ToggleField\r\n\r\nexport interface ButtonField extends BaseField {\r\n    type: FieldType.BUTTON\r\n    text: string\r\n    onClick?: () => void\r\n}\r\nexport interface ToggleField extends BaseField {\r\n    type: FieldType.TOGGLE\r\n    onSelected?: (checked: boolean) => void\r\n}\r\n\r\nexport interface InputField extends BaseField {\r\n    type: FieldType.INPUT\r\n    inputType: string\r\n    onChange?: (value: string) => void\r\n}\r\n\r\nexport interface HiddenField extends BaseField {\r\n    type: FieldType.HIDDEN\r\n}\r\n\r\nexport class SettingsSection {\r\n    private stopHistoryListener: any\r\n    public id: string\r\n\r\n    constructor(public name: string, public sectionFields: { [key: string]: SettingsField } = {}) {\r\n        this.id = _.kebabCase(name)\r\n    }\r\n\r\n    pushSettings = () => {\r\n        if (this.stopHistoryListener) this.stopHistoryListener()\r\n\r\n        this.stopHistoryListener = History.listen(() => this.render())\r\n        this.render()\r\n    }\r\n\r\n    toObject = () =>\r\n        new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop) => SettingsSection.getFieldValue(this.getId(prop.toString())),\r\n            },\r\n        )\r\n\r\n    private render = async () => {\r\n        while (!document.getElementById(\"desktop.settings.selectLanguage\")) {\r\n            if (History.location.pathname !== \"/preferences\") return\r\n            await sleep(100)\r\n        }\r\n\r\n        const allSettingsContainer = document.querySelector(\".x-settings-container\")!\r\n\r\n        let pluginSettingsContainer = Array.from(allSettingsContainer.children).find(({ id }) => id === this.id)\r\n\r\n        if (!pluginSettingsContainer) {\r\n            pluginSettingsContainer = document.createElement(\"div\")\r\n            pluginSettingsContainer.id = this.id\r\n            pluginSettingsContainer.className = \"settingsContainer\"\r\n            allSettingsContainer.appendChild(pluginSettingsContainer)\r\n        }\r\n\r\n        ReactDOM.render(<this.SettingsSection />, pluginSettingsContainer)\r\n    }\r\n\r\n    addButton = (props: FieldToProps<ButtonField>) => {\r\n        this.addField(FieldType.BUTTON, props)\r\n        return this\r\n    }\r\n\r\n    addToggle = (props: FieldToProps<ToggleField>, defaultValue = task.of(false)) => {\r\n        this.addField(FieldType.TOGGLE, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    addInput = (props: FieldToProps<InputField>, defaultValue = task.of(\"\")) => {\r\n        this.addField(FieldType.INPUT, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    private addField(type: FieldType, opts: FieldToProps<SettingsField>, defaultValue?: any) {\r\n        if (defaultValue !== undefined) {\r\n            const settingId = this.getId(opts.id)\r\n            SettingsSection.setDefaultFieldValue(settingId, defaultValue)\r\n        }\r\n        const field = Object.assign({}, opts, { type }) as SettingsField\r\n        this.sectionFields[opts.id] = field\r\n    }\r\n\r\n    getId = (nameId: string) => [\"extensions\", this.id, nameId].join(\":\")\r\n\r\n    private useStateFor = <A,>(id: string) => {\r\n        const [value, setValueState] = React.useState(SettingsSection.getFieldValue<A>(id))\r\n\r\n        return [\r\n            value,\r\n            (newValue: A) => {\r\n                if (newValue !== undefined) {\r\n                    setValueState(newValue)\r\n                    SettingsSection.setFieldValue(id!, newValue)\r\n                }\r\n            },\r\n        ] as const\r\n    }\r\n\r\n    static getFieldValue = <R,>(id: string): R => JSON.parse(LocalStorage.get(id) ?? \"null\")\r\n\r\n    static setFieldValue = (id: string, newValue: any) => LocalStorage.set(id, JSON.stringify(newValue))\r\n\r\n    private static setDefaultFieldValue = async (id: string, defaultValue: task.Task<any>) => {\r\n        if (SettingsSection.getFieldValue(id) === null) SettingsSection.setFieldValue(id, await defaultValue())\r\n    }\r\n\r\n    private toReactComponent = (field: SettingsField) => {\r\n        switch (field.type) {\r\n            case FieldType.BUTTON:\r\n                return this.ButtonField(field)\r\n            case FieldType.TOGGLE:\r\n                return this.ToggleField(field)\r\n            case FieldType.INPUT:\r\n                return this.InputField(field)\r\n            default:\r\n                return <></>\r\n        }\r\n    }\r\n\r\n    private SettingsSection = () => (\r\n        <SettingSection filterMatchQuery={this.name}>\r\n            <SectionTitle>{this.name}</SectionTitle>\r\n            {Object.values(this.sectionFields).map(this.toReactComponent)}\r\n        </SettingSection>\r\n    )\r\n\r\n    SettingField = ({ field, children }: { field: SettingsField; children?: any }) => (\r\n        <SettingColumn filterMatchQuery={field.id}>\r\n            <div className=\"x-settings-firstColumn\">\r\n                <SettingText htmlFor={field.id}>{field.desc}</SettingText>\r\n            </div>\r\n            <div className=\"x-settings-secondColumn\">{children}</div>\r\n        </SettingColumn>\r\n    )\r\n\r\n    ButtonField = (field: ButtonField) => (\r\n        <this.SettingField field={field}>\r\n            <ButtonSecondary id={field.id} buttonSize=\"sm\" onClick={field.onClick} className=\"x-settings-button\">\r\n                {field.text}\r\n            </ButtonSecondary>\r\n        </this.SettingField>\r\n    )\r\n\r\n    ToggleField = (field: ToggleField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<boolean>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <SettingToggle\r\n                    id={field.id}\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    onSelected={(checked: boolean) => {\r\n                        setValue(checked)\r\n                        field.onSelected?.(checked)\r\n                    }}\r\n                    className=\"x-settings-button\"\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n\r\n    InputField = (field: InputField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<string>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <input\r\n                    className=\"x-settings-input\"\r\n                    id={field.id}\r\n                    dir=\"ltr\"\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    type={field.inputType}\r\n                    onChange={e => {\r\n                        const value = e.currentTarget.value\r\n                        setValue(value)\r\n                        field.onChange?.(value)\r\n                    }}\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n}\r\n", "import { _ } from \"./deps.ts\"\r\n\r\n// @ts-expect-error webpackChunkOpen is only defined in the browser\r\nconst require = webpackChunkopen.push([[Symbol(\"Dummy module to extract require method\")], {}, re => re])\r\nconst cache = Object.keys(require.m).map(id => require(id))\r\nexport const modules = cache\r\n    .filter((module): module is Object => typeof module === \"object\")\r\n    .flatMap(module => Object.values(module))\r\nexport const functionModules = modules.filter((module): module is Function => typeof module === \"function\")\r\n\r\n// const reactObjects = modules.filter(m => m?.$$typeof)\r\n\r\n// const reactForwardRefSymbol = Spicetify.React.forwardRef().$$typeof\r\n// const reactForwardRefs = reactObjects.filter(m => m.$$typeof === reactForwardRefSymbol)\r\n\r\n// const reactMemoSymbol = Spicetify.React.memo().$$typeof\r\n// const reactMemos = reactObjects.filter(m => m.$$typeof === reactMemoSymbol)\r\n\r\nconst findModuleByStrings = (modules: Array<any>, ...filters: Array<string | RegExp>) =>\r\n    modules.find(f =>\r\n        _.overEvery(\r\n            filters.map(filter =>\r\n                typeof filter === \"string\" ? (s: string) => s.includes(filter) : (s: string) => filter.test(s),\r\n            ),\r\n        )(f.toString()),\r\n    )\r\n\r\nexport const CheckedPlaylistButtonIcon = findModuleByStrings(\r\n    functionModules,\r\n    \"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm11.748-1.97a.75.75 0 0 0-1.06-1.06l-4.47 4.47-1.405-1.406a.75.75 0 1 0-1.061 1.06l2.466 2.467 5.53-5.53z\",\r\n)\r\n\r\nexport const SettingSection = findModuleByStrings(\r\n    functionModules,\r\n    \"function m(e){return(0,d.jsx)(r.k,{children:(0,d.jsx)(u,{...e})})}\",\r\n)\r\nexport const SectionTitle = findModuleByStrings(functionModules, \"textToHighlight\", \"textBase\")\r\nexport const SettingColumn = findModuleByStrings(functionModules, \"setSectionFilterMatchQueryValue\", \"filterMatchQuery\")\r\nexport const SettingText = findModuleByStrings(functionModules, \"textSubdued\", \"viola\")\r\nexport const SettingToggle = findModuleByStrings(functionModules, \"condensed\", \"onSelected\")\r\n\r\nexport const curationButtonClass = modules.find(m => m?.curationButton)!.curationButton\r\n", "import { AccessToken, SpotifyApi } from \"https://esm.sh/@fostertheweb/spotify-web-api-ts-sdk\"\r\nimport { escapeRegex } from \"./util.ts\"\r\n\r\nconst { CosmosAsync } = Spicetify\r\n\r\nexport const spotifyApi = SpotifyApi.withAccessToken(\"client-id\", {} as AccessToken, {\r\n    // @ts-ignore\r\n    fetch(url, opts) {\r\n        const { method } = opts!\r\n        // @ts-ignore\r\n        return CosmosAsync.resolve(method, url)\r\n    },\r\n    deserializer: {\r\n        deserialize(res) {\r\n            return (res as unknown as Spicetify.CosmosAsync.Response).body\r\n        },\r\n    },\r\n})\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await spotifyApi.search(name, [\"playlist\"])\r\n    const item = res.playlists.items.find(item => item?.owner.id === \"thesoundsofspotify\" && re.test(item.name))\r\n    return item?.uri\r\n}\r\n\r\n/*                          Last FM                                       */\r\n\r\nexport interface fetchLastFMTrackResMinimal {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\nexport const fetchLastFMTrack = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    const res = (await fetch(url).then(res => res.json())) as fetchLastFMTrackResMinimal\r\n\r\n    return res.track\r\n}\r\n\r\n/*                          Youtube                                       */\r\n\r\nexport interface SearchYoutubeResMinimal {\r\n    items: Array<{\r\n        id: {\r\n            videoId: string\r\n        }\r\n        snippet: {\r\n            publishedAt: string\r\n            channelId: string\r\n            title: string\r\n            description: string\r\n            channelTitle: string\r\n            publishTime: string\r\n        }\r\n    }>\r\n}\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as SearchYoutubeResMinimal\r\n}\r\n", "import { Items, ItemsWithCount } from \"./sharedTypes.ts\"\r\n\r\nconst { Locale, GraphQL } = Spicetify\r\n\r\nexport type fetchAlbumRes = {\r\n    __typename: \"album\"\r\n    uri: string\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: string\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: Array<Spicetify.Platform.ImageSized>\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: Array<Spicetify.Platform.ImageSized>\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: ItemsWithCount<{\r\n        uri: string\r\n        name: string\r\n    }>\r\n\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: ItemsWithCount<{\r\n        uid: string\r\n        track: {\r\n            saved: boolean\r\n            uri: string\r\n            name: string\r\n            playcount: string\r\n            discNumber: number\r\n            trackNumber: number\r\n            contentRating: {\r\n                label: string\r\n            }\r\n            relinkingInformation: any\r\n            duration: {\r\n                totalMilliseconds: number\r\n            }\r\n            playability: {\r\n                playable: boolean\r\n            }\r\n            artists: Items<{\r\n                uri: string\r\n                profile: {\r\n                    name: string\r\n                }\r\n            }>\r\n        }\r\n    }>\r\n\r\n    moreAlbumsByArtist: Items<{\r\n        discography: {\r\n            popularReleasesAlbums: Items<{\r\n                id: string\r\n                uri: string\r\n                name: string\r\n                date: {\r\n                    year: number\r\n                }\r\n                coverArt: {\r\n                    sources: Array<Spicetify.Platform.ImageSized>\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                    reason: string\r\n                }\r\n                sharingInfo: {\r\n                    shareId: string\r\n                    shareUrl: string\r\n                }\r\n                type: string\r\n            }>\r\n        }\r\n    }>\r\n}\r\nexport const fetchAlbum = async (uri: string, offset = 0, limit = 487) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.getAlbum, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n        offset,\r\n        limit,\r\n    })\r\n\r\n    return res.data.albumUnion as fetchAlbumRes\r\n}\r\n", "import { Item2, ItemsReleases } from \"./sharedTypes.ts\"\r\n\r\nconst { GraphQL } = Spicetify\r\n\r\nexport type fetchArtistDiscographyRes = {\r\n    __typename: \"artist\"\r\n    discography: {\r\n        all: ItemsReleases<Item2>\r\n    }\r\n}\r\nexport const fetchArtistDiscography = async (uri: string, offset = 0, limit = 116) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistDiscographyAll, {\r\n        uri,\r\n        offset,\r\n        limit,\r\n    })\r\n\r\n    return res.data.artistUnion as fetchArtistDiscographyRes\r\n}\r\n", "import {\r\n    Item1,\r\n    ItemMin,\r\n    Items,\r\n    ItemsReleases,\r\n    ItemsReleasesWithCount,\r\n    ItemsWithCount,\r\n    TopTracksItem,\r\n} from \"./sharedTypes.ts\"\r\n\r\nconst { Locale, GraphQL } = Spicetify\r\n\r\nexport type fetchArtistOverviewRes = {\r\n    __typename: \"Artist\"\r\n    id: string\r\n    uri: string\r\n    saved: boolean\r\n    stats: {\r\n        followers: number\r\n        monthlyListeners: number\r\n        worldRank: number\r\n        topCities: {\r\n            items: Array<{\r\n                numberOfListeners: number\r\n                city: string\r\n                country: string\r\n                region: string\r\n            }>\r\n        }\r\n    }\r\n    profile: {\r\n        name: string\r\n        verified: boolean\r\n        pinnedItem: {\r\n            comment: string\r\n            type: string\r\n            backgroundImage: {\r\n                sources: Array<{ url: string }>\r\n            }\r\n            itemV2: {}\r\n            item: {\r\n                uri: string\r\n                name: string\r\n                images: {\r\n                    items: Array<{\r\n                        sources: Array<{\r\n                            url: string\r\n                            width: null\r\n                            height: null\r\n                        }>\r\n                    }>\r\n                }\r\n            }\r\n        }\r\n        biography: {\r\n            type: string\r\n            text: string\r\n        }\r\n        externalLinks: {\r\n            items: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        playlistV2: {\r\n            totalCount: number\r\n            items: Array<{\r\n                data: {\r\n                    __typename: \"Playlist\"\r\n                    uri: string\r\n                    name: string\r\n                    description: string\r\n                    ownerV2: {\r\n                        data: {\r\n                            __typename: \"User\"\r\n                            name: string\r\n                        }\r\n                    }\r\n                    images: {\r\n                        items: Array<{\r\n                            sources: Array<Spicetify.Platform.ImageSized>\r\n                        }>\r\n                    }\r\n                }\r\n            }>\r\n        }\r\n    }\r\n    visuals: {\r\n        gallery: {\r\n            items: Array<{\r\n                sources: Array<Spicetify.Platform.ImageSized>\r\n            }>\r\n        }\r\n        avatarImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n            extractedColors: {\r\n                colorRaw: {\r\n                    hex: string\r\n                }\r\n            }\r\n        }\r\n        headerImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n            extractedColors: {\r\n                colorRaw: {\r\n                    hex: string\r\n                }\r\n            }\r\n        }\r\n    }\r\n    discography: {\r\n        latest: Item1\r\n        popularReleasesAlbums: ItemsWithCount<Item1>\r\n        singles: ItemsReleases<Item1>\r\n        albums: ItemsReleases<Item1>\r\n        compilations: ItemsReleases<Item1>\r\n        topTracks: Items<TopTracksItem>\r\n    }\r\n    preRelease: any | null\r\n    relatedContent: {\r\n        appearsOn: ItemsReleasesWithCount<\r\n            ItemMin & {\r\n                artists: Items<{\r\n                    uri: string\r\n                    profile: {\r\n                        name: string\r\n                    }\r\n                }>\r\n                date: {\r\n                    year: number\r\n                }\r\n            }\r\n        >\r\n        featuringV2: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n        discoveredOnV2: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n        relatedArtists: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n    }\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    goods: {\r\n        events: {\r\n            userLocation: {\r\n                name: string\r\n            }\r\n            concerts: ItemsWithCount<{\r\n                uri: string\r\n                id: string\r\n                title: string\r\n                category: \"CONCERT\"\r\n                festival: boolean\r\n                nearUser: boolean\r\n                venue: {\r\n                    name: string\r\n                    location: { name: string }\r\n                    coordinates: {\r\n                        latitude: number\r\n                        longitude: number\r\n                    }\r\n                }\r\n                partnerLinks: Items<{\r\n                    partnerName: string\r\n                    url: string\r\n                }>\r\n\r\n                date: Date\r\n            }> & {\r\n                pagingInfo: {\r\n                    limit: number\r\n                }\r\n            }\r\n        }\r\n        merch: Items<{\r\n            image: {\r\n                sources: Array<{ url: string }>\r\n            }\r\n            name: string\r\n            description: string\r\n            price: string\r\n            uri: string\r\n            url: string\r\n        }>\r\n    }\r\n}\r\nexport const fetchArtistOverview = async (uri: string) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistOverview, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n        includePrerelease: true,\r\n    })\r\n\r\n    return res.data.artistUnion as fetchArtistOverviewRes\r\n}\r\n", "import { _ } from \"./deps.ts\"\r\n\r\nconst { Snackbar } = Spicetify\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const chunkify50 =\r\n    <A, R>(fn: (a: Array<A>) => R) =>\r\n    async (args: Array<A>) => {\r\n        const a = await Promise.all(_.chunk(args, 50).map(fn))\r\n        return a.flat()\r\n    }\r\n\r\nexport const progressify = <F extends (...args: any) => any>(f: F, n: number) => {\r\n    let i = n,\r\n        lastProgress = 0\r\n    return async function (..._: Parameters<F>): Promise<Awaited<ReturnType<F>>> {\r\n        const res = (await f(...arguments)) as Awaited<ReturnType<F>>,\r\n            progress = Math.round((1 - --i / n) * 100)\r\n        if (progress > lastProgress) {\r\n            ;(Snackbar as any).updater.enqueueSetState(Snackbar, () => ({\r\n                snacks: [],\r\n                queue: [],\r\n            }))\r\n            Snackbar.enqueueSnackbar(`Loading: ${progress}%`, {\r\n                variant: \"default\",\r\n                autoHideDuration: 200,\r\n                transitionDuration: {\r\n                    enter: 0,\r\n                    exit: 0,\r\n                },\r\n            })\r\n        }\r\n        lastProgress = progress\r\n        return res\r\n    }\r\n}\r\n", "import { Track } from \"https://esm.sh/v135/@fostertheweb/spotify-web-api-ts-sdk/dist/mjs/types.js\"\r\nimport { fetchAlbumRes } from \"./GraphQL/fetchAlbum.ts\"\r\nimport { TopTracksItem } from \"./GraphQL/sharedTypes.ts\"\r\n\r\nexport type TrackData = {\r\n    uri: string\r\n    uid?: string\r\n    name: string\r\n    albumUri: string\r\n    albumName?: string\r\n    artistUris: string[]\r\n    artistName: string\r\n    durationMilis: number\r\n    playcount?: number\r\n    popularity?: number\r\n    releaseDate?: number\r\n    lastfmPlaycount?: number\r\n    scrobbles?: number\r\n    personalScrobbles?: number\r\n}\r\n\r\nexport const parseTopTrackFromArtist = ({ track }: TopTracksItem) => ({\r\n    uri: track.uri,\r\n    uid: undefined,\r\n    name: track.name,\r\n    albumUri: track.albumOfTrack.uri,\r\n    albumName: undefined,\r\n    artistUris: track.artists.items.map(artist => artist.uri),\r\n    artistName: track.artists.items[0].profile.name,\r\n    durationMilis: track.duration.totalMilliseconds,\r\n    playcount: Number(track.playcount),\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n})\r\n\r\nexport const parseArtistLikedTrack = (track: Spicetify.Platform.Track) => ({\r\n    uri: track.uri,\r\n    uid: undefined,\r\n    name: track.name,\r\n    albumUri: track.album.uri,\r\n    albumName: track.album.name,\r\n    artistUris: track.artists.map(artist => artist.uri),\r\n    artistName: track.artists[0].name,\r\n    durationMilis: track.duration.milliseconds,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n})\r\n\r\nexport const parseAlbumTrack = ({ track }: fetchAlbumRes[\"tracks\"][\"items\"][0]) => ({\r\n    uri: track.uri,\r\n    uid: undefined,\r\n    name: track.name,\r\n    albumUri: \"\", // gets filled in later\r\n    albumName: \"\", // gets filled in later\r\n    artistUris: track.artists.items.map(artist => artist.uri),\r\n    artistName: track.artists.items[0].profile.name,\r\n    durationMilis: track.duration.totalMilliseconds,\r\n    playcount: Number(track.playcount),\r\n    popularity: undefined,\r\n    releaseDate: -1, // gets filled in later\r\n})\r\n\r\nexport const parsePlaylistAPITrack = (track: Spicetify.Platform.PlaylistAPI.Track) => ({\r\n    uri: track.uri,\r\n    uid: track.uid,\r\n    name: track.name,\r\n    albumUri: track.album.uri,\r\n    albumName: track.album.name,\r\n    artistUris: track.artists.map(artist => artist.uri),\r\n    artistName: track.artists[0].name,\r\n    durationMilis: track.duration.milliseconds,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n})\r\n\r\nexport const parseWebAPITrack = (track: Track) => ({\r\n    uri: track.uri,\r\n    uid: undefined,\r\n    name: track.name,\r\n    albumUri: track.album.uri,\r\n    albumName: track.album.name,\r\n    artistUris: track.artists.map(artist => artist.uri),\r\n    artistName: track.artists[0].name,\r\n    durationMilis: track.duration_ms,\r\n    playcount: undefined,\r\n    popularity: track.popularity,\r\n    releaseDate: new Date(track.album.release_date).getTime(),\r\n})\r\n\r\nexport const parseLibraryAPILikedTracks = (track: Spicetify.Platform.Track) => ({\r\n    uri: track.uri,\r\n    uid: undefined,\r\n    name: track.name,\r\n    albumUri: track.album.uri,\r\n    albumName: track.album.name,\r\n    artistUris: track.artists.map(artist => artist.uri),\r\n    artistName: track.artists[0].name,\r\n    durationMilis: track.duration.milliseconds,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n})\r\n", "import { fetchAlbum } from \"../../shared/GraphQL/fetchAlbum.ts\"\r\nimport { fetchArtistDiscography } from \"../../shared/GraphQL/fetchArtistDiscography.ts\"\r\nimport { fetchArtistOverview } from \"../../shared/GraphQL/fetchArtistOveriew.ts\"\r\nimport { ItemMin, ItemsReleases, ItemsReleasesWithCount, ItemsWithCount } from \"../../shared/GraphQL/sharedTypes.ts\"\r\nimport { _, fp } from \"../../shared/deps.ts\"\r\nimport { pMchain } from \"../../shared/fp.ts\"\r\nimport {\r\n    TrackData,\r\n    parseAlbumTrack,\r\n    parseArtistLikedTrack,\r\n    parseLibraryAPILikedTracks,\r\n    parsePlaylistAPITrack,\r\n    parseTopTrackFromArtist,\r\n} from \"../../shared/parse.ts\"\r\nimport { fetchArtistLikedTracks, fetchLikedTracks, fetchPlaylistContents } from \"../../shared/platformApi.ts\"\r\nimport { SpotifyURI } from \"../../shared/util.ts\"\r\n\r\nimport { CONFIG } from \"./settings.ts\"\r\n\r\nexport const getTracksFromAlbum = async (uri: string) => {\r\n    const albumRes = await fetchAlbum(uri)\r\n    const releaseDate = new Date(albumRes.date.isoString).getTime()\r\n\r\n    const filler = {\r\n        albumUri: albumRes.uri,\r\n        albumName: albumRes.name,\r\n        releaseDate,\r\n    }\r\n\r\n    return Promise.all(\r\n        albumRes.tracks.items.map(async track => {\r\n            const parsedTrack = await parseAlbumTrack(track)\r\n            return Object.assign(parsedTrack, filler) as TrackData\r\n        }),\r\n    )\r\n}\r\n\r\nexport const getLikedTracks = _.flow(fetchLikedTracks, pMchain(fp.map(parseLibraryAPILikedTracks)))\r\n\r\nexport const getTracksFromPlaylist = _.flow(fetchPlaylistContents, pMchain(fp.map(parsePlaylistAPITrack)))\r\n\r\nexport const getTracksFromArtist = async (uri: SpotifyURI) => {\r\n    const allTracks = new Array<TrackData>()\r\n\r\n    const itemsWithCountAr = new Array<ItemsWithCount<ItemMin>>()\r\n    const itemsReleasesAr = new Array<ItemsReleases<ItemMin>>()\r\n    const appearsOnAr = new Array<ItemsReleasesWithCount<ItemMin>>()\r\n\r\n    if (CONFIG.artistAllDiscography) {\r\n        const { discography } = await fetchArtistDiscography(uri)\r\n        itemsReleasesAr.push(discography.all)\r\n    } else {\r\n        const { discography, relatedContent } = await fetchArtistOverview(uri)\r\n\r\n        CONFIG.artistLikedTracks && allTracks.push(...(await fetchArtistLikedTracks(uri)).map(parseArtistLikedTrack))\r\n        CONFIG.artistTopTracks && allTracks.push(...discography.topTracks.items.map(parseTopTrackFromArtist))\r\n        CONFIG.artistPopularReleases && itemsWithCountAr.push(discography.popularReleasesAlbums)\r\n        CONFIG.artistSingles && itemsReleasesAr.push(discography.singles)\r\n        CONFIG.artistAlbums && itemsReleasesAr.push(discography.albums)\r\n        CONFIG.artistCompilations && itemsReleasesAr.push(discography.compilations)\r\n        CONFIG.artistAppearsOn && appearsOnAr.push(relatedContent.appearsOn)\r\n    }\r\n\r\n    const items1 = itemsWithCountAr.flatMap(iwc => iwc.items)\r\n    const items2 = itemsReleasesAr.flatMap(ir => ir.items.flatMap(i => i.releases.items))\r\n    const albumLikeUris = items1.concat(items2).map(item => item.uri)\r\n    const albumsTracks = await Promise.all(albumLikeUris.map(getTracksFromAlbum))\r\n\r\n    const appearsOnUris = appearsOnAr.flatMap(ir => ir.items.flatMap(i => i.releases.items)).map(item => item.uri)\r\n    const appearsOnTracks = await Promise.all(appearsOnUris.map(getTracksFromAlbum))\r\n\r\n    allTracks.push(...albumsTracks.flat(), ...appearsOnTracks.flat().filter(track => track.artistUris.includes(uri)))\r\n    return await Promise.all(allTracks)\r\n}\r\n", "import { spotifyApi } from \"../../shared/api.ts\"\r\nimport { _ } from \"../../shared/deps.ts\"\r\nimport { TrackData } from \"../../shared/parse.ts\"\r\n\r\nimport { getLikedTracks, getTracksFromAlbum, getTracksFromArtist, getTracksFromPlaylist } from \"./fetch.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nexport const SEPARATOR_URI = \"spotify:separator\"\r\n\r\nexport enum ERROR {\r\n    LAST_SORTED_QUEUE_EMPTY = \"Must sort to queue beforehand\",\r\n    LAST_SORTED_QUEUE_NOT_A_PLAYLIST = \"Last sorted queue must be a playlist\",\r\n}\r\n\r\nexport type AsyncTracksOperation = (tracks: TrackData[]) => Promise<TrackData[]> | TrackData[]\r\n\r\nexport enum SortAction {\r\n    SPOTIFY_PLAYCOUNT = \"Spotify - Play Count\",\r\n    SPOTIFY_POPULARITY = \"Spotify - Popularity\",\r\n    SPOTIFY_RELEASEDATE = \"Spotify - Release Date\",\r\n    LASTFM_SCROBBLES = \"LastFM - Scrobbles\",\r\n    LASTFM_PERSONALSCROBBLES = \"LastFM - My Scrobbles\",\r\n    LASTFM_PLAYCOUNT = \"LastFM - Play Count\",\r\n}\r\n\r\nexport enum SortActionIcon {\r\n    \"Spotify - Play Count\" = \"play\",\r\n    \"Spotify - Popularity\" = \"heart\",\r\n    \"Spotify - Release Date\" = \"list-view\",\r\n    \"LastFM - Scrobbles\" = \"volume\",\r\n    \"LastFM - My Scrobbles\" = \"artist\",\r\n    \"LastFM - Play Count\" = \"subtitles\",\r\n}\r\n\r\nexport enum SortActionProp {\r\n    \"Spotify - Play Count\" = \"playcount\",\r\n    \"Spotify - Popularity\" = \"popularity\",\r\n    \"Spotify - Release Date\" = \"releaseDate\",\r\n    \"LastFM - Scrobbles\" = \"scrobbles\",\r\n    \"LastFM - My Scrobbles\" = \"personalScrobbles\",\r\n    \"LastFM - Play Count\" = \"lastfmPlaycount\",\r\n}\r\n\r\nexport const joinByUri = (...trackss: TrackData[][]) => {\r\n    const tracks = [...trackss].flat()\r\n    const uriTrackPairs = tracks.map(track => [track.uri, track] as const)\r\n    return Array.from(new Map(uriTrackPairs).values())\r\n}\r\n\r\nexport const URI_isLikedTracks = (uri: string) => {\r\n    const uriObj = URI.fromString(uri)\r\n    return uriObj.type === URI.Type.COLLECTION && uriObj.category === \"tracks\"\r\n}\r\n\r\nexport const getNameFromUri = async (uri: Spicetify.URI) => {\r\n    switch (uri.type) {\r\n        case URI.Type.ALBUM: {\r\n            const album = await spotifyApi.albums.get(uri.id!)\r\n            return album.name\r\n        }\r\n\r\n        case URI.Type.ARTIST: {\r\n            const artist = await spotifyApi.artists.get(uri.id!)\r\n            return artist.name\r\n        }\r\n\r\n        case URI.Type.COLLECTION:\r\n            if (uri.category === \"tracks\") return \"Liked Tracks\"\r\n            else break\r\n\r\n        case URI.Type.PLAYLIST:\r\n        case URI.Type.PLAYLIST_V2: {\r\n            const playlist = await spotifyApi.playlists.getPlaylist(uri.id!)\r\n            return playlist.name\r\n        }\r\n    }\r\n}\r\n\r\nexport const getTracksFromUri = _.cond([\r\n    [URI.isAlbum, getTracksFromAlbum],\r\n    [URI.isArtist, getTracksFromArtist],\r\n    [URI_isLikedTracks, getLikedTracks],\r\n    [URI.isPlaylistV1OrV2, getTracksFromPlaylist],\r\n])\r\n", "import {\r\n    createPlaylistFromTracks,\r\n    fetchFolder,\r\n    fetchRootFolder,\r\n    movePlaylistTracks,\r\n    setPlaylistVisibility,\r\n} from \"../../shared/platformApi.ts\"\r\nimport { SpotifyLoc } from \"../../shared/util.ts\"\r\n\r\nimport { lastFetchedUri, lastSortAction } from \"./app.ts\"\r\nimport { CONFIG } from \"./settings.ts\"\r\nimport { ERROR, getNameFromUri } from \"./util.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nexport const createPlaylistFromLastSortedQueue = async () => {\r\n    if (lastSortedQueue.length === 0) {\r\n        Spicetify.showNotification(ERROR.LAST_SORTED_QUEUE_EMPTY)\r\n        return\r\n    }\r\n\r\n    const sortedPlaylistsFolder = await fetchFolder(CONFIG.sortedPlaylistsFolderUri).catch(fetchRootFolder)\r\n\r\n    const uri = URI.fromString(lastFetchedUri)\r\n    const playlistName = `${getNameFromUri(uri)} - ${lastSortAction}`\r\n\r\n    const { palylistUri } = await createPlaylistFromTracks(\r\n        playlistName,\r\n        lastSortedQueue.map(t => t.uri),\r\n        sortedPlaylistsFolder.uri,\r\n    )\r\n\r\n    setPlaylistVisibility(palylistUri, false)\r\n\r\n    Spicetify.showNotification(`Playlist ${playlistName} created`)\r\n}\r\n\r\nexport const reordedPlaylistLikeSortedQueue = async () => {\r\n    if (lastSortedQueue.length === 0) {\r\n        Spicetify.showNotification(ERROR.LAST_SORTED_QUEUE_EMPTY)\r\n        return\r\n    }\r\n\r\n    if (!URI.isPlaylistV1OrV2(lastFetchedUri)) {\r\n        Spicetify.showNotification(ERROR.LAST_SORTED_QUEUE_NOT_A_PLAYLIST)\r\n        return\r\n    }\r\n\r\n    const fn = (uid: string) => movePlaylistTracks(lastFetchedUri, [uid], SpotifyLoc.after.end())\r\n    await Promise.all(lastSortedQueue.map(track => track.uid!).map(fn))\r\n}\r\n", "import { fetchLastFMTrack, spotifyApi } from \"../../shared/api.ts\"\r\nimport { _, fp } from \"../../shared/deps.ts\"\r\nimport { chunkify50, progressify } from \"../../shared/fp.ts\"\r\nimport { TrackData, parseWebAPITrack } from \"../../shared/parse.ts\"\r\n\r\nimport { getTracksFromAlbum } from \"./fetch.ts\"\r\nimport { CONFIG } from \"./settings.ts\"\r\nimport { SortAction, SortActionProp, joinByUri } from \"./util.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nconst fillTracksFromWebAPI = async (tracks: TrackData[]) => {\r\n    const ids = tracks.map(track => URI.fromString(track.uri)!.id!)\r\n\r\n    const fetchedTracks = await chunkify50(is => spotifyApi.tracks.get(is))(ids)\r\n    return joinByUri(tracks, fetchedTracks.map(parseWebAPITrack))\r\n}\r\n\r\nconst fillTracksFromAlbumTracks = async (tracks: TrackData[]) => {\r\n    const tracksByAlbumUri = Object.groupBy(tracks, track => track.albumUri)\r\n    const passes = Object.keys(tracksByAlbumUri).length\r\n    const fn = progressify(async (tracks: TrackData[]) => {\r\n        const albumTracks = await getTracksFromAlbum(tracks[0].albumUri)\r\n        return _.intersectionBy(albumTracks, tracks, track => track.uri)\r\n    }, passes)\r\n\r\n    const sameAlbumTracksArray = Object.values(tracksByAlbumUri)\r\n    const albumsTracks = await Promise.all(sameAlbumTracksArray.map(fn))\r\n    return albumsTracks.flat()\r\n}\r\n\r\nexport const fillTracksFromSpotify = (propName: SortAction) => async (tracks: TrackData[]) => {\r\n    const tracksMissing = tracks.filter(track => track[SortActionProp[propName]] == null)\r\n    const tracksPopulater = _.cond([\r\n        [fp.startsWith(SortAction.SPOTIFY_PLAYCOUNT), () => fillTracksFromAlbumTracks],\r\n        [_.stubTrue, () => fillTracksFromWebAPI],\r\n    ])(propName)\r\n    const filledTracks = await tracksPopulater(tracksMissing)\r\n    return joinByUri(tracks, filledTracks)\r\n}\r\n\r\nconst fillTrackFromLastFM = async (track: TrackData) => {\r\n    const lastfmTrack = await fetchLastFMTrack(CONFIG.LFMApiKey, track.artistName, track.name, CONFIG.lastFmUsername)\r\n    track.lastfmPlaycount = Number(lastfmTrack.listeners)\r\n    track.scrobbles = Number(lastfmTrack.playcount)\r\n    track.personalScrobbles = Number(lastfmTrack.userplaycount)\r\n    return track\r\n}\r\n\r\nexport const fillTracksFromLastFM = (tracks: TrackData[]) => {\r\n    const fn = progressify(fillTrackFromLastFM, tracks.length)\r\n    return Promise.all(tracks.map(fn))\r\n}\r\n", "import { _, fp } from \"../../shared/deps.ts\"\r\nimport { TrackData } from \"../../shared/parse.ts\"\r\nimport { SpotifyURI, createQueueItem, setPlayingContext, setQueue as _setQueue } from \"../../shared/util.ts\"\r\n\r\nimport { createPlaylistFromLastSortedQueue, reordedPlaylistLikeSortedQueue } from \"./playlistsInterop.ts\"\r\nimport { fillTracksFromLastFM, fillTracksFromSpotify } from \"./populate.ts\"\r\nimport { CONFIG } from \"./settings.ts\"\r\nimport {\r\n    AsyncTracksOperation,\r\n    SEPARATOR_URI,\r\n    SortAction,\r\n    SortActionIcon,\r\n    SortActionProp,\r\n    URI_isLikedTracks,\r\n    getTracksFromUri,\r\n} from \"./util.ts\"\r\n\r\nconst { URI, ContextMenu, Topbar } = Spicetify\r\nconst { PlayerAPI } = Spicetify.Platform\r\n\r\nexport let lastFetchedUri: SpotifyURI\r\nexport let lastSortAction: SortAction | \"True Shuffle\" | \"Stars\"\r\nexport let lastSortedQueue: TrackData[] = []\r\n\r\nlet invertOrder = 0\r\naddEventListener(\"keydown\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 1\r\n})\r\n\r\naddEventListener(\"keyup\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 0\r\n})\r\n\r\nconst populateTracks: (sortProp: SortAction) => AsyncTracksOperation = _.cond([\r\n    [fp.startsWith(\"Spotify\"), fillTracksFromSpotify],\r\n    [fp.startsWith(\"LastFM\"), () => fillTracksFromLastFM],\r\n])\r\n\r\nconst setQueue = (reverse: boolean) => (tracks: TrackData[]) => {\r\n    if (PlayerAPI?._state?.item?.uid == undefined) return void Spicetify.showNotification(\"Queue is null!\", true)\r\n\r\n    const dedupedQueue = _.uniqBy(tracks, \"uri\")\r\n    reverse && dedupedQueue.reverse()\r\n\r\n    global.lastSortedQueue = lastSortedQueue = dedupedQueue\r\n\r\n    const isLikedTracks = URI_isLikedTracks(lastFetchedUri)\r\n\r\n    const queue = lastSortedQueue.concat({ uri: SEPARATOR_URI } as TrackData).map(createQueueItem(isLikedTracks))\r\n\r\n    return _setQueue(queue, isLikedTracks ? undefined : lastFetchedUri)\r\n}\r\n\r\n// Menu\r\n\r\nconst sortTracksBy = (sortAction: typeof lastSortAction, sortFn: AsyncTracksOperation) => async (uri: SpotifyURI) => {\r\n    lastSortAction = sortAction\r\n    const descending = invertOrder ^ Number(CONFIG.descending)\r\n    lastFetchedUri = uri\r\n    const tracks = await getTracksFromUri(uri)\r\n    const sortedTracks = await sortFn(tracks)\r\n    return await setQueue(!!descending)(sortedTracks)\r\n}\r\n\r\nconst createSubMenuForSortProp = (sortAction: SortAction) =>\r\n    new ContextMenu.Item(\r\n        sortAction,\r\n        ([uri]) => {\r\n            const sortActionProp = SortActionProp[sortAction]\r\n            const sortFn = async (tracks: TrackData[]) => {\r\n                const filledTracks = await populateTracks(sortAction)(tracks)\r\n                const filteredTracks = filledTracks.filter(track => track[sortActionProp] != null)\r\n                return _.sortBy(filteredTracks, sortActionProp)\r\n            }\r\n            sortTracksBy(sortAction, sortFn)(uri)\r\n        },\r\n        _.stubTrue,\r\n        SortActionIcon[sortAction],\r\n        false,\r\n    )\r\nconst sortTracksByShuffle = sortTracksBy(\"True Shuffle\", _.shuffle)\r\nconst sortTracksByStars = sortTracksBy(\r\n    \"Stars\",\r\n    fp.sortBy((track: TrackData) => tracksRatings[track.uri] ?? 0),\r\n)\r\n\r\nconst SubMenuItems = Object.values(SortAction).map(createSubMenuForSortProp)\r\nconst SubMenuItemShuffle = new ContextMenu.Item(\r\n    \"True Shuffle\",\r\n    ([uri]) => sortTracksByShuffle(uri),\r\n    _.stubTrue,\r\n    \"shuffle\",\r\n    false,\r\n)\r\nconst SubMenuItemStars = new ContextMenu.Item(\r\n    \"Stars\",\r\n    ([uri]) => sortTracksByStars(uri),\r\n    () => global.tracksRatings !== undefined,\r\n    \"heart-active\",\r\n    false,\r\n)\r\nSubMenuItems.push(SubMenuItemShuffle, SubMenuItemStars)\r\n\r\nconst SortBySubMenu = new ContextMenu.SubMenu(\"Sort by\", SubMenuItems, ([uri]) =>\r\n    _.overSome([URI.isAlbum, URI.isArtist, URI_isLikedTracks, URI.isTrack, URI.isPlaylistV1OrV2])(uri),\r\n)\r\nSortBySubMenu.register()\r\n\r\n// Topbar\r\n\r\nnew Topbar.Button(\"Create a Playlist from Sorted Queue\", \"plus2px\", createPlaylistFromLastSortedQueue)\r\nnew Topbar.Button(\"Reorder current Playlist like Sorted Queue\", \"chart-down\", reordedPlaylistLikeSortedQueue)\r\n"],
  "mappings": "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",
  "names": ["task", "require", "modules", "History", "History", "value", "task", "CosmosAsync", "res", "GraphQL", "Locale", "GraphQL", "_", "URI", "SortAction", "SortActionIcon", "SortActionProp", "URI", "URI", "URI", "tracks", "URI", "PlayerAPI", "lastSortedQueue", "setQueue"]
}
