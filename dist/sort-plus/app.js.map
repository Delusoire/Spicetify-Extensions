{
  "version": 3,
  "sources": ["../../extensions/sort-plus/app.ts", "../../shared/fp.ts", "../../shared/util.ts", "../../shared/api.ts", "../../shared/parse.ts", "../../extensions/sort-plus/settings.ts", "../../shared/settings.tsx", "../../shared/modules.ts"],
  "sourcesContent": ["import {\r\n    array as ar,\r\n    eq,\r\n    function as f,\r\n    nonEmptyArray as nea,\r\n    number as num,\r\n    option as o,\r\n    ord,\r\n    record as rec,\r\n    string as str,\r\n    task,\r\n} from \"https://esm.sh/fp-ts\"\r\nimport { guard } from \"https://esm.sh/fp-ts-std/Function\"\r\nimport { anyPass } from \"https://esm.sh/fp-ts-std/Predicate\"\r\nimport { values } from \"https://esm.sh/fp-ts-std/Record\"\r\nimport {\r\n    createSPPlaylistFromTracks,\r\n    fetchGQLAlbum,\r\n    fetchGQLArtistDiscography,\r\n    fetchGQLArtistOverview,\r\n    fetchPlatArtistLikedTracks,\r\n    fetchPlatFolder,\r\n    fetchPlatLikedTracks,\r\n    fetchPlatPlaylistContents,\r\n    fetchPlatRootFolder,\r\n    fetchTrackLFMAPI,\r\n    fetchWebAlbumsSpot,\r\n    fetchWebArtistsSpot,\r\n    fetchWebPlaylistsSpot,\r\n    fetchWebTracksSpot,\r\n    movePlatPlaylistTracks,\r\n    setPlatPlaylistVisibility,\r\n} from \"../../shared/api.ts\"\r\nimport { objConcat, pMchain, tapAny, withProgress } from \"../../shared/fp.ts\"\r\nimport {\r\n    TrackData,\r\n    TracksPopulater,\r\n    parseAPITrackFromPlaylist,\r\n    parseAPITrackFromSpotify,\r\n    parsePlatLikedTracks,\r\n    parsePlatTrackFromArtistLikedTracks,\r\n    parseTopTrackFromArtist,\r\n    parseTrackFromAlbum,\r\n} from \"../../shared/parse.ts\"\r\nimport { SpotifyID, SpotifyLoc, SpotifyURI, createQueueItem, setPlayingContext, setQueue } from \"../../shared/util.ts\"\r\nimport { CONFIG } from \"./settings.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nenum SortBy {\r\n    SPOTIFY_PLAYCOUNT = \"Spotify - Play Count\",\r\n    SPOTIFY_POPULARITY = \"Spotify - Popularity\",\r\n    SPOTIFY_RELEASEDATE = \"Spotify - Release Date\",\r\n    LASTFM_SCROBBLES = \"LastFM - Scrobbles\",\r\n    LASTFM_PERSONALSCROBBLES = \"LastFM - My Scrobbles\",\r\n    LASTFM_PLAYCOUNT = \"LastFM - Play Count\",\r\n}\r\n\r\nenum SortProp {\r\n    \"Spotify - Play Count\" = \"playcount\",\r\n    \"Spotify - Popularity\" = \"popularity\",\r\n    \"Spotify - Release Date\" = \"releaseDate\",\r\n    \"LastFM - Scrobbles\" = \"scrobbles\",\r\n    \"LastFM - My Scrobbles\" = \"personalScrobbles\",\r\n    \"LastFM - Play Count\" = \"lastfmPlaycount\",\r\n}\r\n\r\n// Fetching Tracks\r\n\r\nconst getAlbumTracks = async (uri: SpotifyURI) => {\r\n    const albumRes = await fetchGQLAlbum(uri)\r\n    const releaseDate = new Date(albumRes.date.isoString).getTime()\r\n\r\n    const filler = {\r\n        albumUri: albumRes.uri,\r\n        albumName: albumRes.name,\r\n        releaseDate,\r\n    }\r\n\r\n    return f.pipe(albumRes.tracks.items, ar.map(f.flow(parseTrackFromAlbum, track => Object.assign(track, filler))))\r\n}\r\n\r\nconst getPlaylistTracks = f.flow(fetchPlatPlaylistContents, pMchain(ar.map(parseAPITrackFromPlaylist)))\r\n\r\nasync function getArtistTracks(uri: SpotifyURI) {\r\n    const extractUriFromReleases = (x: { releases: { items: Array<{ uri: SpotifyURI }> } }) => x.releases.items[0].uri\r\n    const getTracksFromAlbums = f.flow(ar.map(getAlbumTracks), ps => Promise.all(ps), pMchain(ar.flatten))\r\n\r\n    const allTracks = new Array<TrackData | Promise<TrackData>>()\r\n\r\n    const add = (tracks: TrackData[]) => {\r\n        allTracks.push(...tracks)\r\n    }\r\n\r\n    const albumsLike = []\r\n    const albumsLikeReleases = []\r\n\r\n    if (CONFIG.artistAllDiscography) {\r\n        const disc = await fetchGQLArtistDiscography(uri)\r\n        albumsLikeReleases.push(...disc)\r\n    } else {\r\n        const disc = (await fetchGQLArtistOverview(uri)).discography\r\n\r\n        if (CONFIG.artistLikedTracks) {\r\n            const likedTracks = await fetchPlatArtistLikedTracks(uri)\r\n            f.pipe(likedTracks, ar.map(parsePlatTrackFromArtistLikedTracks), add)\r\n        }\r\n\r\n        if (CONFIG.artistTopTracks)\r\n            f.pipe(\r\n                disc.topTracks.items,\r\n                ar.map(i => i.track),\r\n                ar.map(parseTopTrackFromArtist),\r\n                add,\r\n            )\r\n\r\n        if (CONFIG.artistPopularReleases) albumsLike.push(...disc.popularReleasesAlbums.items.map(r => r.uri))\r\n        if (CONFIG.artistSingles) albumsLikeReleases.push(...disc.singles.items)\r\n        if (CONFIG.artistAlbums) albumsLikeReleases.push(...disc.albums.items)\r\n        if (CONFIG.artistCompilations) albumsLikeReleases.push(...disc.compilations.items)\r\n    }\r\n\r\n    albumsLike.push(...albumsLikeReleases.map(extractUriFromReleases))\r\n    await f.pipe(albumsLike, getTracksFromAlbums, pMchain(add))\r\n\r\n    return await Promise.all(allTracks)\r\n}\r\n\r\n// ------------- For populateTracksSpot -------------\r\nconst fetchAPITracksFromTracks: TracksPopulater = f.flow(\r\n    ar.map(({ uri }) => URI.fromString(uri)!.id!),\r\n    fetchWebTracksSpot,\r\n    pMchain(ar.map(parseAPITrackFromSpotify)),\r\n)\r\n\r\nconst fetchAlbumTracksFromTracks: TracksPopulater = f.flow(\r\n    nea.groupBy(track => track.albumUri!),\r\n    withProgress(rec.mapWithIndex<SpotifyURI, TrackData[], Promise<TrackData[]>>)(async (albumUri, tracks) => {\r\n        const uriEq = f.pipe(\r\n            str.Eq,\r\n            eq.contramap((t: TrackData) => t.uri),\r\n        )\r\n\r\n        const albumTracks = await getAlbumTracks(albumUri)\r\n\r\n        return ar.intersection(uriEq)(albumTracks, tracks)\r\n    }),\r\n    values,\r\n    ps => Promise.all(ps),\r\n    pMchain(ar.flatten),\r\n)\r\n// --------------------------------------------------\r\n\r\nconst populateTracksSpot = (propName: keyof typeof SortProp) => (tracks: TrackData[]) =>\r\n    f.pipe(\r\n        tracks,\r\n        ar.filter(x => x[SortProp[propName]] == null),\r\n        guard([[str.startsWith(SortBy.SPOTIFY_PLAYCOUNT), f.constant(fetchAlbumTracksFromTracks)]])(\r\n            f.constant(fetchAPITracksFromTracks),\r\n        )(propName),\r\n        pMchain(ar.concat(tracks)),\r\n        pMchain(nea.groupBy(x => x.uri)),\r\n        pMchain(values<TrackData[]>),\r\n        pMchain(ar.map(objConcat<TrackData>())),\r\n    )\r\n\r\nconst populateTrackLastFM = async (track: TrackData) => {\r\n    const lastfmTrack = (await fetchTrackLFMAPI(CONFIG.LFMApiKey, track.artistName, track.name, CONFIG.lastFmUsername))\r\n        .track\r\n    track.lastfmPlaycount = Number(lastfmTrack.listeners)\r\n    track.scrobbles = Number(lastfmTrack.playcount)\r\n    track.personalScrobbles = Number(lastfmTrack.userplaycount)\r\n    return track\r\n}\r\n\r\n// Fetching, Sorting and Playing\r\n\r\nconst fetchTracks = f.flow(\r\n    tapAny(uri => void (lastFetchedUri = uri)),\r\n    guard<SpotifyURI, Promise<TrackData[]>>([\r\n        [URI.isAlbum, getAlbumTracks],\r\n        [URI.isArtist, getArtistTracks],\r\n        [URI.isPlaylistV1OrV2, getPlaylistTracks],\r\n        [URI.isCollection, f.flow(fetchPlatLikedTracks, pMchain(ar.map(parsePlatLikedTracks)))],\r\n    ])(task.of([])),\r\n)\r\n\r\nconst populateTracks = guard<keyof typeof SortProp, TracksPopulater>([\r\n    [str.startsWith(\"Spotify\"), populateTracksSpot],\r\n    [\r\n        str.startsWith(\"LastFM\"),\r\n        f.constant(\r\n            f.flow(f.pipe(withProgress(ar.map<TrackData, Promise<TrackData>>)(populateTrackLastFM)), ps =>\r\n                Promise.all(ps),\r\n            ),\r\n        ),\r\n    ],\r\n])(f.constant(task.of([])))\r\n\r\nlet lastSortedQueue: TrackData[] = []\r\n;(globalThis as any).lastSortedQueue = lastSortedQueue\r\nconst _setQueue = (inverted: boolean) => async (queue: TrackData[]) => {\r\n    if (Spicetify.Platform.PlayerAPI._queue._queue === null)\r\n        return void Spicetify.showNotification(\"Queue is null!\", true)\r\n\r\n    const uriOrd = f.pipe(\r\n        str.Ord,\r\n        ord.contramap((t: TrackData) => t.uri),\r\n    )\r\n\r\n    lastSortedQueue = f.pipe(queue, ar.uniq(uriOrd), inverted ? ar.reverse : f.identity)\r\n    console.log(\"\uD83D\uDE80 ~ file: app.tsx:217 ~ const_setQueue= ~ inverted:\", inverted)\r\n    console.log(\"\uD83D\uDE80 ~ file: app.tsx:217 ~ const_setQueue= ~ lastSortedQueue:\", lastSortedQueue)\r\n    ;(globalThis as any).lastSortedQueue = lastSortedQueue\r\n\r\n    const isQueued = URI.isCollection(lastFetchedUri)\r\n\r\n    await f.pipe(\r\n        lastSortedQueue,\r\n        ar.map(t => t.uri),\r\n        ar.concat([\"spotify:separator\"]),\r\n        ar.map(createQueueItem(isQueued)),\r\n        setQueue,\r\n    )\r\n    if (!isQueued) await setPlayingContext(lastFetchedUri)\r\n    await Spicetify.Platform.PlayerAPI.skipToNext()\r\n}\r\n\r\nlet lastFetchedUri: SpotifyURI\r\nlet lastActionName: keyof typeof SortProp | \"True Shuffle\" | \"Stars\"\r\nconst sortByProp = (name: keyof typeof SortProp) => async (uri: SpotifyURI) => {\r\n    lastActionName = name\r\n    const descending = invertOrder ^ Number(CONFIG.descending)\r\n    console.log(\"\uD83D\uDE80 ~ file: app.tsx:236 ~ sortByProp ~ descending:\", descending)\r\n    console.log(\"\uD83D\uDE80 ~ file: app.tsx:236 ~ sortByProp ~ invertOrder:\", invertOrder)\r\n    console.log(\"\uD83D\uDE80 ~ file: app.tsx:236 ~ sortByProp ~ CONFIG.descending:\", CONFIG.descending)\r\n\r\n    const propOrd = f.pipe(\r\n        num.Ord,\r\n        ord.contramap((t: Required<TrackData>) => t[SortProp[name]]),\r\n    )\r\n\r\n    f.pipe(\r\n        uri,\r\n        fetchTracks,\r\n        pMchain(populateTracks(name)),\r\n        pMchain(ar.map(x => (x[SortProp[name]] != null ? o.some(x as Required<TrackData>) : o.none))),\r\n        pMchain(ar.sequence(o.Applicative)),\r\n        pMchain(o.map(ar.sort(propOrd))),\r\n        pMchain(o.map(_setQueue(!!descending))),\r\n    )\r\n}\r\n\r\nlet invertOrder = 0\r\nwindow.addEventListener(\"keydown\", event => {\r\n    if (!event.repeat && event.key === \"Control\") {\r\n        debugger\r\n        invertOrder = 1\r\n    }\r\n})\r\n\r\nwindow.addEventListener(\"keyup\", event => {\r\n    if (!event.repeat && event.key === \"Control\") invertOrder = 0\r\n})\r\n\r\n// Menu\r\n\r\nconst fetchSortQueue =\r\n    (name: typeof lastActionName, sortFn: (tracksIn: TrackData[]) => TrackData[]) =>\r\n    ([uri]: [SpotifyURI]) => {\r\n        lastActionName = name\r\n        const descending = invertOrder ^ Number(CONFIG.descending)\r\n        f.pipe(uri, fetchTracks, pMchain(sortFn), pMchain(_setQueue(!!descending)))\r\n    }\r\n\r\nconst shuffle = <A>(array: A[], l = array.length): A[] =>\r\n    l == 0 ? [] : [array.splice(Math.floor(Math.random() * l), 1)[0], ...shuffle(array)]\r\nconst shuffleSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"True Shuffle\",\r\n    fetchSortQueue(\"True Shuffle\", shuffle) as any,\r\n    f.constTrue,\r\n    \"shuffle\",\r\n    false,\r\n)\r\n\r\nconst starsOrd = f.pipe(\r\n    num.Ord,\r\n    ord.contramap((t: { uri: SpotifyURI }) => (globalThis as any).tracksRatings[t.uri] ?? 0),\r\n)\r\nconst starsSubmenu = new Spicetify.ContextMenu.Item(\r\n    \"Stars\",\r\n    fetchSortQueue(\"Stars\", ar.sort(starsOrd)) as any,\r\n    () => (globalThis as any).tracksRatings !== undefined,\r\n    \"heart-active\",\r\n    false,\r\n)\r\n\r\nconst createSortByPropSubmenu = (name: keyof typeof SortProp, icon: any) =>\r\n    new Spicetify.ContextMenu.Item(name, f.tupled(sortByProp(name)) as any, f.constTrue, icon, false)\r\n\r\nnew Spicetify.ContextMenu.SubMenu(\r\n    \"Sort by\",\r\n    ar\r\n        .zipWith(\r\n            values(SortBy),\r\n            [\"play\", \"heart\", \"list-view\", \"volume\", \"artist\", \"subtitles\"],\r\n            createSortByPropSubmenu,\r\n        )\r\n        .concat([shuffleSubmenu, starsSubmenu]),\r\n    f.tupled(anyPass([URI.isAlbum, URI.isArtist, URI.isPlaylistV1OrV2, URI.isCollection])) as any,\r\n).register()\r\n\r\n// Topbar\r\n\r\nconst generatePlaylistName = async () => {\r\n    const uriToId = (uri: SpotifyURI) => URI.fromString(uri)!.id!\r\n    const getName = (fn: Function) => async (id: SpotifyID) => (await fn([id]))[0].name\r\n\r\n    const collectionName = await guard([\r\n        [URI.isAlbum, f.flow(uriToId, getName(fetchWebAlbumsSpot))],\r\n        [URI.isArtist, f.flow(uriToId, getName(fetchWebArtistsSpot))],\r\n        [URI.isPlaylistV1OrV2, f.flow(uriToId, getName(fetchWebPlaylistsSpot))],\r\n        [URI.isCollection, task.of(\"Liked Tracks\")],\r\n    ])(task.of(\"Unresolved\"))(lastFetchedUri)\r\n\r\n    return `${collectionName} - ${lastActionName}`\r\n}\r\nnew Spicetify.Topbar.Button(\"Add Sorted Queue to Sorted Playlists\", \"plus2px\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n\r\n    const sortedPlaylistsFolder = await fetchPlatFolder(CONFIG.sortedPlaylistsFolderUri).catch(fetchPlatRootFolder)\r\n\r\n    const playlistName = await generatePlaylistName()\r\n\r\n    const { uri } = await createSPPlaylistFromTracks(\r\n        playlistName,\r\n        lastSortedQueue.map(t => t.uri),\r\n        sortedPlaylistsFolder.uri,\r\n    )\r\n\r\n    setPlatPlaylistVisibility(uri, false)\r\n\r\n    Spicetify.showNotification(`Playlist ${playlistName} created`)\r\n})\r\n\r\nnew Spicetify.Topbar.Button(\"Reorder Playlist with Sorted Queue\", \"chart-down\", async () => {\r\n    if (lastSortedQueue.length === 0) return void Spicetify.showNotification(\"Must sort to queue beforehand\")\r\n    if (!URI.isPlaylistV1OrV2(lastFetchedUri))\r\n        return void Spicetify.showNotification(\"Last sorted queue must be a playlist\")\r\n\r\n    f.pipe(\r\n        lastSortedQueue as unknown as Array<{ uid: string }>,\r\n        withProgress(ar.map<{ uid: string }, void>)(\r\n            t => void movePlatPlaylistTracks(lastFetchedUri, [t], SpotifyLoc.after.end()),\r\n        ),\r\n    )\r\n})\r\n", "import {\r\n    array as ar,\r\n    eq,\r\n    string as str,\r\n    record as rec,\r\n    refinement as ref,\r\n    semigroup as sg,\r\n    function as f,\r\n} from \"https://esm.sh/fp-ts\"\r\nimport { guard, memoize } from \"https://esm.sh/fp-ts-std/Function\"\r\n\r\ntype refineBranch<A, B extends A, R> = [ref.Refinement<A, B>, (x: B) => R]\r\nexport const guard2 = <A, A1 extends A, A2 extends A, R>(branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>]) =>\r\n    guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard3 = <A, A1 extends A, A2 extends A, A3 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>],\r\n) => guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>, refineBranch<A, A, R>])\r\n\r\nexport const objConcat2 = <A1, A2>() => rec.getUnionSemigroup(sg.first<any>()).concat as (x: A1, y: A2) => A1 & A2\r\nexport const objConcat = <A>() => ar.reduce({} as A, objConcat2<A, A>())\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const is =\r\n    <A>(c: keyof A) =>\r\n    <B extends A>(a: A[typeof c]) =>\r\n    (field: A): field is B =>\r\n        field[c] === a\r\n\r\nexport const tapAny =\r\n    <A>(f: (a: A) => void) =>\r\n    (fa: A) => {\r\n        f(fa)\r\n        return fa\r\n    }\r\n\r\nexport const chunckify =\r\n    (n: number) =>\r\n    <A, R>(g: (a: A[]) => Promise<R[]>) =>\r\n        f.flow(ar.chunksOf(n)<A>, ar.map(g), ps => Promise.all(ps), pMchain(ar.flatten))\r\n\r\nexport const withProgress =\r\n    <F extends (f: (...a: any) => any) => (fa: any) => any>(map: F) =>\r\n    (f: Parameters<F>[0]) =>\r\n    (fa: Parameters<ReturnType<F>>[0]): ReturnType<ReturnType<F>> => {\r\n        let i = 0\r\n        return map(async (...a: Parameters<Parameters<F>[0]>) => {\r\n            // @ts-expect-error: Fuck me\r\n            const ret = await f(...a)\r\n            const progress = Math.round((i++ / Object.values(fa).length) * 100)\r\n            Spicetify.showNotification(`Loading: ${progress}%`, false, 200)\r\n            return ret\r\n        })(fa)\r\n    }\r\n\r\nexport const memoize2 = <A extends any[], R>(fn: (...args: A) => R) =>\r\n    f.pipe(fn, f.tupled, memoize<A>(eq.contramap(JSON.stringify)(str.Eq)), f.untupled)\r\n", "import { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLocObj = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport const SpotifyLoc = {\r\n    before: {\r\n        start: f.constant({ before: \"start\" } as SpotifyLocObj),\r\n        fromUri: (uri: SpotifyURI) => ({ before: { uri } }),\r\n        fromUid: (uid: string) => ({ before: { uid } }),\r\n    },\r\n    after: {\r\n        end: f.constant({ after: \"end\" } as SpotifyLocObj),\r\n        fromUri: (uri: SpotifyURI) => ({ after: { uri } }),\r\n        fromUid: (uid: string) => ({ after: { uid } }),\r\n    },\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E | null,\r\n) =>\r\n    new Promise((resolve: (value: Element) => void, reject) => {\r\n        const onMutation = () => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el) {\r\n                if (notEl && el === notEl) {\r\n                } else {\r\n                    observer.disconnect()\r\n                    return resolve(el)\r\n                }\r\n            }\r\n        }\r\n\r\n        const observer = new MutationObserver(onMutation)\r\n        onMutation()\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout)\r\n            setTimeout(() => {\r\n                observer.disconnect()\r\n                reject()\r\n            }, timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n\r\nexport const onHistoryChanged = (\r\n    toMatchTo: string | RegExp | ((location: string) => boolean),\r\n    callback: (uri: SpotifyURI) => void,\r\n    dropDuplicates = true,\r\n) => {\r\n    const createMatchFn = (toMatchTo: string | RegExp | ((input: string) => boolean)) => {\r\n        switch (typeof toMatchTo) {\r\n            case \"string\":\r\n                return (input: string) => input?.startsWith(toMatchTo) ?? false\r\n\r\n            case \"function\":\r\n                return toMatchTo\r\n\r\n            default:\r\n                return (input: string) => toMatchTo.test(input)\r\n        }\r\n    }\r\n\r\n    let lastPathname = \"\"\r\n    const matchFn = createMatchFn(toMatchTo)\r\n\r\n    const historyChanged = ({ pathname }: any) => {\r\n        if (matchFn(pathname)) {\r\n            if (dropDuplicates && lastPathname === pathname) {\r\n            } else callback(Spicetify.URI.fromString(pathname).toString())\r\n        }\r\n        lastPathname = pathname\r\n    }\r\n\r\n    historyChanged(Spicetify.Platform.History.location ?? {})\r\n    Spicetify.Platform.History.listen(historyChanged)\r\n}\r\n\r\nexport const onSongChanged = (callback: (state?: Spicetify.PlayerState) => void) => {\r\n    callback(Spicetify.Player.data)\r\n    Spicetify.Player.addEventListener(\"songchange\", event => callback(event!.data))\r\n}\r\n", "import { chunckify, memoize2 } from \"./fp.ts\"\r\nimport { SpotifyID, SpotifyLocObj, SpotifyURI, escapeRegex } from \"./util.ts\"\r\nimport { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const isPlatTrackLiked = (uris: SpotifyURI[]) =>\r\n    Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setPlatTrackLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"]({ uris })\r\n\r\nexport const togglePlatTrackLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isPlatTrackLiked(uris)\r\n\r\n    return await f.pipe(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setPlatTrackLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setPlatTrackLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const addPlatPlaylist = async (playlist: SpotifyURI, folder?: SpotifyURI, addedAt = new Date()) =>\r\n    await Spicetify.Platform.RootlistAPI.add([playlist], { after: { type: \"folder\", addedAt, uri: folder } })\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLocObj = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const removePlatPlaylistTracks = async (playlist: SpotifyURI, tracks: Array<{ uid: string }>) =>\r\n    Spicetify.Platform.PlaylistAPI.remove(playlist, tracks)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n", "import { SpotApiTrack, fetchGQLAlbumRes, fetchPlatArtistLikedTracksRes, fetchWebPlaylistRes } from \"./api.ts\"\r\nimport { SpotifyURI } from \"./util.ts\"\r\n\r\nexport type TrackData = {\r\n    albumName?: string\r\n    albumUri: SpotifyURI\r\n    artistName: string\r\n    artistUri: SpotifyURI\r\n    durationMilis: number\r\n    name: string\r\n    playcount?: number\r\n    popularity?: number\r\n    releaseDate?: number\r\n    uri: SpotifyURI\r\n    lastfmPlaycount?: number\r\n    scrobbles?: number\r\n    personalScrobbles?: number\r\n}\r\n\r\nexport type UnparsedTrack = any\r\nexport type TrackParser = (track: UnparsedTrack) => TrackData\r\nexport type TracksPopulater = (tracks: TrackData[]) => Promise<TrackData[]>\r\n\r\nexport const parseTrackFromAlbum = ({ track }: fetchGQLAlbumRes[\"tracks\"][\"items\"][0]) => ({\r\n    albumName: \"\", // gets filled in later\r\n    albumUri: \"\", // gets filled in later\r\n    artistName: track.artists.items[0].profile.name,\r\n    artistUri: track.artists.items[0].uri,\r\n    durationMilis: track.duration.totalMilliseconds,\r\n    name: track.name,\r\n    playcount: Number(track.playcount),\r\n    popularity: undefined,\r\n    releaseDate: -1, // gets filled in later\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parseTopTrackFromArtist = (track: UnparsedTrack) => ({\r\n    albumName: undefined,\r\n    albumUri: track.albumOfTrack.uri as SpotifyURI,\r\n    artistName: track.artists.items[0].profile.name as string,\r\n    artistUri: track.artists.items[0].uri as SpotifyURI,\r\n    durationMilis: track.duration.totalMilliseconds as number,\r\n    name: track.name as string,\r\n    playcount: Number(track.playcount) as number,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri as SpotifyURI,\r\n})\r\n\r\nexport const parsePlatTrackFromArtistLikedTracks = (track: fetchPlatArtistLikedTracksRes[0]) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration.milliseconds,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri,\r\n})\r\n\r\n// NOT USED\r\n// export const parseTrackFromPlaylistSP = (track: UnparsedTrack) => ({\r\n//     albumName: track.album.name,\r\n//     albumUri: track.album.link,\r\n//     artistName: track.artists[0].name,\r\n//     artistUri: track.artists[0].link,\r\n//     durationMilis: track.length * 1000,\r\n//     name: track.name,\r\n//     playcount: undefined,\r\n//     popularity: track.popularity,\r\n//     releaseDate: undefined,\r\n//     uri: track.link,\r\n// })\r\n\r\nexport const parseAPITrackFromPlaylist = (track: fetchWebPlaylistRes[0]) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration.milliseconds,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uid: track.uid,\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parseAPITrackFromSpotify = (track: SpotApiTrack) => ({\r\n    albumName: track.album.name,\r\n    albumUri: track.album.uri,\r\n    artistName: track.artists[0].name,\r\n    artistUri: track.artists[0].uri,\r\n    durationMilis: track.duration_ms,\r\n    name: track.name,\r\n    playcount: undefined,\r\n    popularity: track.popularity,\r\n    releaseDate: new Date(track.album.release_date).getTime(),\r\n    uri: track.uri,\r\n})\r\n\r\nexport const parsePlatLikedTracks = (track: UnparsedTrack) => ({\r\n    albumName: track.album.name as string,\r\n    albumUri: track.album.uri as SpotifyURI,\r\n    artistName: track.artists[0].name as string,\r\n    artistUri: track.artists[0].uri as SpotifyURI,\r\n    durationMilis: track.duration.milliseconds as number,\r\n    name: track.name as string,\r\n    playcount: undefined,\r\n    popularity: undefined,\r\n    releaseDate: undefined,\r\n    uri: track.uri as SpotifyURI,\r\n})\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\nimport { createPlatFolder } from \"../../shared/api.ts\"\r\nimport { SettingsSection } from \"../../shared/settings.tsx\"\r\nimport { SpotifyURI } from \"../../shared/util.ts\"\r\n\r\nconst SORTED_PLAYLISTS_FOLDER_NAME = \"Sorted Playlists\"\r\n\r\nconst settings = new SettingsSection(\"Sort+\", \"sort-plus\")\r\n    .addToggle({ id: \"descending\", desc: \"Descending\" }, task.of(true))\r\n    .addToggle({ id: \"artistAllDiscography\", desc: \"All of the artist's Discography\" })\r\n    .addToggle({ id: \"artistTopTracks\", desc: \"Top Tracks\" }, task.of(true))\r\n    .addToggle({ id: \"artistPopularReleases\", desc: \"Popular Releases\" }, task.of(true))\r\n    .addToggle({ id: \"artistSingles\", desc: \"Singles\" })\r\n    .addToggle({ id: \"artistAlbums\", desc: \"Albums\" })\r\n    .addToggle({ id: \"artistCompilations\", desc: \"Compilations\" })\r\n    .addToggle({ id: \"artistLikedTracks\", desc: \"Liked Tracks\" }, task.of(true))\r\n    .addInput({ id: \"lastFmUsername\", desc: \"Last.fm Username\", inputType: \"text\" }, task.of(\"Username\"))\r\n    .addInput(\r\n        { id: \"LFMApiKey\", desc: \"Last.fm API Key\", inputType: \"text\" },\r\n        task.of(\"********************************\"),\r\n    )\r\n    .addInput(\r\n        {\r\n            id: \"sortedPlaylistsFolderUri\",\r\n            desc: \"Sorted Playlists folder uri\",\r\n            inputType: \"text\",\r\n        },\r\n        async () => (await createPlatFolder(SORTED_PLAYLISTS_FOLDER_NAME)).uri,\r\n    )\r\n\r\nsettings.pushSettings()\r\n\r\nexport const CONFIG = settings.toObject() as {\r\n    artistAllDiscography: boolean\r\n    artistTopTracks: boolean\r\n    artistPopularReleases: boolean\r\n    artistSingles: boolean\r\n    artistAlbums: boolean\r\n    artistCompilations: boolean\r\n    artistLikedTracks: boolean\r\n    descending: boolean\r\n    lastFmUsername: string\r\n    LFMApiKey: string\r\n    sortedPlaylistsFolderUri: SpotifyURI\r\n}\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\nimport { guard3, is } from \"./fp.ts\"\r\nimport { sleep } from \"./util.ts\"\r\nimport { SettingSection, SettingColumn, SettingText, SettingToggle, SectionTitle } from \"./modules.ts\"\r\n\r\nconst { React, ReactDOM } = Spicetify\r\nconst { ButtonSecondary } = Spicetify.ReactComponent as any\r\n\r\ntype FieldToProps<A> = Omit<A, \"type\">\r\n\r\nexport const enum FieldType {\r\n    BUTTON = \"button\",\r\n    TOGGLE = \"toggle\",\r\n    INPUT = \"input\",\r\n    HIDDEN = \"hidden\",\r\n}\r\n\r\nexport interface BaseField {\r\n    id: string\r\n    type: FieldType\r\n    desc: string\r\n}\r\n\r\nexport type SettingsField = HiddenField | InputField | ButtonField | ToggleField\r\n\r\nexport interface ButtonField extends BaseField {\r\n    type: FieldType.BUTTON\r\n    text: string\r\n    onClick?: () => void\r\n}\r\nexport interface ToggleField extends BaseField {\r\n    type: FieldType.TOGGLE\r\n    onSelected?: (checked: boolean) => void\r\n}\r\n\r\nexport interface InputField extends BaseField {\r\n    type: FieldType.INPUT\r\n    inputType: string\r\n    onChange?: (value: string) => void\r\n}\r\n\r\nexport interface HiddenField extends BaseField {\r\n    type: FieldType.HIDDEN\r\n}\r\n\r\nexport class SettingsSection {\r\n    private stopHistoryListener: any\r\n\r\n    constructor(public name: string, public id: string, public sectionFields: { [key: string]: SettingsField } = {}) {}\r\n\r\n    pushSettings = () => {\r\n        if (this.stopHistoryListener) this.stopHistoryListener()\r\n\r\n        this.stopHistoryListener = Spicetify.Platform.History.listen(() => this.render())\r\n        this.render()\r\n    }\r\n\r\n    toObject = () =>\r\n        new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop) => SettingsSection.getFieldValue(this.getId(prop.toString())),\r\n            },\r\n        )\r\n\r\n    private render = async () => {\r\n        while (!document.getElementById(\"desktop.settings.selectLanguage\")) {\r\n            if (Spicetify.Platform.History.location.pathname !== \"/preferences\") return\r\n            await sleep(100)\r\n        }\r\n\r\n        const allSettingsContainer = document.querySelector(\".x-settings-container\")!\r\n\r\n        let pluginSettingsContainer = Array.from(allSettingsContainer.children).find(({ id }) => id === this.id)\r\n\r\n        if (!pluginSettingsContainer) {\r\n            pluginSettingsContainer = document.createElement(\"div\")\r\n            pluginSettingsContainer.id = this.id\r\n            pluginSettingsContainer.className = \"settingsContainer\"\r\n            allSettingsContainer.appendChild(pluginSettingsContainer)\r\n        }\r\n\r\n        ReactDOM.render(<this.SettingsSection />, pluginSettingsContainer)\r\n    }\r\n\r\n    addButton = (props: FieldToProps<ButtonField>) => {\r\n        this.addField(FieldType.BUTTON, props)\r\n        return this\r\n    }\r\n\r\n    addToggle = (props: FieldToProps<ToggleField>, defaultValue = task.of(false)) => {\r\n        this.addField(FieldType.TOGGLE, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    addInput = (props: FieldToProps<InputField>, defaultValue = task.of(\"\")) => {\r\n        this.addField(FieldType.INPUT, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    private addField(type: FieldType, opts: FieldToProps<SettingsField>, defaultValue?: any) {\r\n        if (defaultValue !== undefined) {\r\n            const settingId = this.getId(opts.id)\r\n            SettingsSection.setDefaultFieldValue(settingId, defaultValue)\r\n        }\r\n        const field = Object.assign({}, opts, { type }) as SettingsField\r\n        this.sectionFields[opts.id] = field\r\n    }\r\n\r\n    getId = (nameId: string) => [\"extensions\", this.id, nameId].join(\":\")\r\n\r\n    private useStateFor = <A,>(id: string) => {\r\n        const [value, setValueState] = React.useState(SettingsSection.getFieldValue<A>(id))\r\n\r\n        return [\r\n            value,\r\n            (newValue: A) => {\r\n                if (newValue !== undefined) {\r\n                    setValueState(newValue)\r\n                    SettingsSection.setFieldValue(id!, newValue)\r\n                }\r\n            },\r\n        ] as const\r\n    }\r\n\r\n    static getFieldValue = <R,>(id: string): R => JSON.parse(Spicetify.LocalStorage.get(id) ?? \"null\")\r\n\r\n    static setFieldValue = (id: string, newValue: any) => Spicetify.LocalStorage.set(id, JSON.stringify(newValue))\r\n\r\n    private static setDefaultFieldValue = async (id: string, defaultValue: task.Task<any>) => {\r\n        if (SettingsSection.getFieldValue(id) === null) SettingsSection.setFieldValue(id, await defaultValue())\r\n    }\r\n\r\n    private SettingsSection = () => (\r\n        <SettingSection filterMatchQuery={this.name}>\r\n            <SectionTitle>{this.name}</SectionTitle>\r\n            {Object.values(this.sectionFields).map(field => {\r\n                const isType = is<SettingsField>(\"type\")\r\n\r\n                return guard3([\r\n                    [isType<InputField>(FieldType.INPUT), this.InputField],\r\n                    [isType(FieldType.BUTTON), this.ButtonField],\r\n                    [isType(FieldType.TOGGLE), this.ToggleField],\r\n                ])(() => <></>)(field)\r\n            })}\r\n        </SettingSection>\r\n    )\r\n\r\n    SettingField = ({ field, children }: { field: SettingsField; children?: any }) => (\r\n        <SettingColumn filterMatchQuery={field.id}>\r\n            <div className=\"x-settings-firstColumn\">\r\n                <SettingText htmlFor={field.id}>{field.desc}</SettingText>\r\n            </div>\r\n            <div className=\"x-settings-secondColumn\">{children}</div>\r\n        </SettingColumn>\r\n    )\r\n\r\n    ButtonField = (field: ButtonField) => (\r\n        <this.SettingField field={field}>\r\n            <ButtonSecondary id={field.id} buttonSize=\"sm\" onClick={field.onClick} className=\"x-settings-button\">\r\n                {field.text}\r\n            </ButtonSecondary>\r\n        </this.SettingField>\r\n    )\r\n\r\n    ToggleField = (field: ToggleField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<boolean>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <SettingToggle\r\n                    id={field.id}\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    onSelected={(checked: boolean) => {\r\n                        setValue(checked)\r\n                        field.onSelected?.(checked)\r\n                    }}\r\n                    className=\"x-settings-button\"\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n\r\n    InputField = (field: InputField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<string>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <input\r\n                    className=\"x-settings-input\"\r\n                    id={field.id}\r\n                    dir=\"ltr\"\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    type={field.inputType}\r\n                    onChange={e => {\r\n                        const value = e.currentTarget.value\r\n                        setValue(value)\r\n                        field.onChange?.(value)\r\n                    }}\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n}\r\n", "import { allPass } from \"https://esm.sh/fp-ts-std@0.18.0/Predicate\"\r\n\r\n// @ts-expect-error webpackChunkOpen is only defined in the browser\r\nconst require = webpackChunkopen.push([[Symbol(\"Dummy module to extract require method\")], {}, re => re])\r\nconst cache = Object.keys(require.m).map(id => require(id))\r\nexport const modules = cache\r\n    .filter((module): module is Object => typeof module === \"object\")\r\n    .flatMap(module => Object.values(module))\r\nexport const functionModules = modules.filter((module): module is Function => typeof module === \"function\")\r\n\r\nexport const reactObjects = modules.filter(m => m?.$$typeof)\r\nconst reactMemoSymbol = Spicetify.React.memo().$$typeof\r\nexport const reactMemos = reactObjects.filter(m => m.$$typeof === reactMemoSymbol)\r\n\r\nconst findModuleByStrings = (modules: Array<any>, ...filters: Array<string | RegExp>) =>\r\n    modules.find(f =>\r\n        allPass(\r\n            filters.map(filter =>\r\n                typeof filter === \"string\" ? (s: string) => s.includes(filter) : (s: string) => filter.test(s),\r\n            ),\r\n        )(f.toString()),\r\n    ) as any\r\n\r\nexport const CheckedPlaylistButtonIcon = findModuleByStrings(\r\n    functionModules,\r\n    \"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm11.748-1.97a.75.75 0 0 0-1.06-1.06l-4.47 4.47-1.405-1.406a.75.75 0 1 0-1.061 1.06l2.466 2.467 5.53-5.53z\",\r\n)\r\n\r\nexport const SettingSection = findModuleByStrings(\r\n    functionModules,\r\n    \"function m(e){return(0,d.jsx)(r.k,{children:(0,d.jsx)(u,{...e})})}\",\r\n)\r\nexport const SectionTitle = findModuleByStrings(functionModules, \"textToHighlight\", \"textBase\")\r\nexport const SettingColumn = findModuleByStrings(functionModules, \"setSectionFilterMatchQueryValue\", \"filterMatchQuery\")\r\nexport const SettingText = findModuleByStrings(functionModules, \"textSubdued\", \"viola\")\r\nexport const SettingToggle = findModuleByStrings(functionModules, \"condensed\", \"onSelected\")\r\n\r\nexport const curationButtonClass = modules.find(m => m?.curationButton)!.curationButton\r\n"],
  "mappings": "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",
  "names": ["ar", "eq", "f", "rec", "str", "task", "guard", "f", "a", "f", "a", "f", "task", "require", "modules", "f", "value", "task", "SortBy", "SortProp", "f", "ar", "rec", "str", "eq", "guard", "task"]
}
