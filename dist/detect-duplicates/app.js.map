{
  "version": 3,
  "sources": ["../../extensions/star-ratings-2/util.ts", "../../shared/GraphQL/searchModalResults.ts", "../../shared/api.ts", "../../shared/util.ts", "../../shared/deps.ts", "../../shared/fp.ts", "../../extensions/detect-duplicates/util.ts", "../../extensions/detect-duplicates/app.ts"],
  "sourcesContent": ["export const RATINGS_FOLDER_NAME = \"Ratings\"\r\n\r\nexport const getTrackLists = () => Array.from(document.querySelectorAll<HTMLDivElement>(\".main-trackList-indexable\"))\r\nexport const getTrackListTracks = (trackList: HTMLDivElement) =>\r\n    Array.from(trackList.querySelectorAll<HTMLDivElement>(\"div.main-trackList-trackListRow\"))\r\n\r\nexport const getTrackListTrackUri = (track: HTMLDivElement) => (\r\n    (track = Object.values(track)[0].child.child.child.child),\r\n    (track as any).pendingProps.uri ?? (track as any).child.pendingProps.uri\r\n)\r\n\r\nexport const getNowPlayingBar = () => document.querySelector<HTMLDivElement>(\"div.main-nowPlayingBar-nowPlayingBar\")!\r\nexport const getCollectionActionBarRow = () => document.querySelector<HTMLDivElement>(`div.main-actionBar-ActionBarRow`)\r\n\r\nexport const playlistButtonSelector = `button[aria-label=\"Add to Liked Songs\"], button[aria-label=\"Add to playlist\"], button[aria-label=\"Remove recommendation\"]`\r\nexport const getPlaylistButton = (parent: HTMLElement) =>\r\n    parent.querySelector<HTMLButtonElement>(playlistButtonSelector)!\r\nexport const getCollectionPlaylistButton = () => {\r\n    const ab = getCollectionActionBarRow()\r\n    return ab?.querySelector<HTMLButtonElement>(\r\n        `button[aria-label=\"Remove from Your Library\"], button[aria-label=\"Save to Your Library\"]`,\r\n    )\r\n}\r\n", "import { Items } from \"../api.ts\"\r\n\r\nconst { GraphQL } = Spicetify\r\n\r\ntype Track = {\r\n    __typename: \"Track\"\r\n    uri: string\r\n    name: string\r\n    albumOfTrack: {\r\n        coverArt: {\r\n            extractedColors: {\r\n                colorDark: {\r\n                    hex: string\r\n                    isFallback: boolean\r\n                }\r\n            }\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n        }\r\n    }\r\n    artists: Items<{\r\n        profile: {\r\n            name: string\r\n        }\r\n    }>\r\n}\r\n\r\ntype TrackResponseWrapper = {\r\n    __typename: \"TrackResponseWrapper\"\r\n    data: Track\r\n}\r\n\r\ntype searchGQLRes = Array<{\r\n    matchedFields: string[]\r\n    item: TrackResponseWrapper\r\n}>\r\nexport const searchGQL = async (q: string, offset = 0, limit = 10, topResultsNum = 20, includeAudiobooks = true) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.searchModalResults, {\r\n        searchTerm: q,\r\n        offset,\r\n        limit,\r\n        numberOfTopResults: topResultsNum,\r\n        includeAudiobooks,\r\n    })\r\n\r\n    return res.data.searchV2.topResults.itemsV2 as searchGQLRes\r\n}\r\n", "import { AccessToken, SpotifyApi } from \"https://esm.sh/@fostertheweb/spotify-web-api-ts-sdk\"\r\nimport { SpotifyURI, escapeRegex } from \"./util.ts\"\r\n\r\nconst { Locale, GraphQL, CosmosAsync } = Spicetify\r\n\r\nexport const spotifyApi = SpotifyApi.withAccessToken(\"client-id\", {} as AccessToken, {\r\n    // @ts-ignore\r\n    fetch(url, opts) {\r\n        const { method } = opts!\r\n        // @ts-ignore\r\n        return CosmosAsync.resolve(method, url)\r\n    },\r\n    deserializer: {\r\n        deserialize(res) {\r\n            return (res as unknown as Spicetify.CosmosAsync.Response).body\r\n        },\r\n    },\r\n})\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport type fetchGQLAlbumRes = {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: Array<Spicetify.Platform.ImageSized>\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: Array<Spicetify.Platform.ImageSized>\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: ItemsWithCount<{\r\n        uri: SpotifyURI\r\n        name: string\r\n    }>\r\n\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: ItemsWithCount<{\r\n        uid: string\r\n        track: {\r\n            saved: boolean\r\n            uri: SpotifyURI\r\n            name: string\r\n            playcount: string\r\n            discNumber: number\r\n            trackNumber: number\r\n            contentRating: {\r\n                label: string\r\n            }\r\n            relinkingInformation: any\r\n            duration: {\r\n                totalMilliseconds: number\r\n            }\r\n            playability: {\r\n                playable: boolean\r\n            }\r\n            artists: Items<{\r\n                uri: SpotifyURI\r\n                profile: {\r\n                    name: string\r\n                }\r\n            }>\r\n        }\r\n    }>\r\n\r\n    moreAlbumsByArtist: Items<{\r\n        discography: {\r\n            popularReleasesAlbums: Items<{\r\n                id: string\r\n                uri: SpotifyURI\r\n                name: string\r\n                date: {\r\n                    year: number\r\n                }\r\n                coverArt: {\r\n                    sources: Array<Spicetify.Platform.ImageSized>\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                    reason: string\r\n                }\r\n                sharingInfo: {\r\n                    shareId: string\r\n                    shareUrl: string\r\n                }\r\n                type: string\r\n            }>\r\n        }\r\n    }>\r\n}\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.getAlbum, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n        offset,\r\n        limit,\r\n    })\r\n\r\n    return res.data.albumUnion as fetchGQLAlbumRes\r\n}\r\n\r\nexport type fetchGQLArtistOverviewRes = {\r\n    __typename: \"Artist\"\r\n    id: string\r\n    uri: string\r\n    saved: boolean\r\n    stats: {\r\n        followers: number\r\n        monthlyListeners: number\r\n        worldRank: number\r\n        topCities: {\r\n            items: Array<{\r\n                numberOfListeners: number\r\n                city: string\r\n                country: string\r\n                region: string\r\n            }>\r\n        }\r\n    }\r\n    profile: {\r\n        name: string\r\n        verified: boolean\r\n        pinnedItem: {\r\n            comment: string\r\n            type: string\r\n            backgroundImage: {\r\n                sources: Array<{ url: string }>\r\n            }\r\n            itemV2: {}\r\n            item: {\r\n                uri: string\r\n                name: string\r\n                images: {\r\n                    items: Array<{\r\n                        sources: Array<{\r\n                            url: string\r\n                            width: null\r\n                            height: null\r\n                        }>\r\n                    }>\r\n                }\r\n            }\r\n        }\r\n        biography: {\r\n            type: string\r\n            text: string\r\n        }\r\n        externalLinks: {\r\n            items: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        playlistV2: {\r\n            totalCount: number\r\n            items: Array<{\r\n                data: {\r\n                    __typename: \"Playlist\"\r\n                    uri: string\r\n                    name: string\r\n                    description: string\r\n                    ownerV2: {\r\n                        data: {\r\n                            __typename: \"User\"\r\n                            name: string\r\n                        }\r\n                    }\r\n                    images: {\r\n                        items: Array<{\r\n                            sources: Array<Spicetify.Platform.ImageSized>\r\n                        }>\r\n                    }\r\n                }\r\n            }>\r\n        }\r\n    }\r\n    visuals: {\r\n        gallery: {\r\n            items: Array<{\r\n                sources: Array<Spicetify.Platform.ImageSized>\r\n            }>\r\n        }\r\n        avatarImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n            extractedColors: {\r\n                colorRaw: {\r\n                    hex: string\r\n                }\r\n            }\r\n        }\r\n        headerImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n            extractedColors: {\r\n                colorRaw: {\r\n                    hex: string\r\n                }\r\n            }\r\n        }\r\n    }\r\n    discography: {\r\n        latest: Item1\r\n        popularReleasesAlbums: ItemsWithCount<Item1>\r\n        singles: ItemsReleases<Item1>\r\n        albums: ItemsReleases<Item1>\r\n        compilations: ItemsReleases<Item1>\r\n        topTracks: Items<TopTracksItem>\r\n    }\r\n    preRelease: any | null\r\n    relatedContent: {\r\n        appearsOn: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n        featuringV2: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n        discoveredOnV2: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n        relatedArtists: {\r\n            totalCount: number\r\n            items: any[]\r\n        }\r\n    }\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    goods: {\r\n        events: {\r\n            userLocation: {\r\n                name: string\r\n            }\r\n            concerts: ItemsWithCount<{\r\n                uri: string\r\n                id: string\r\n                title: string\r\n                category: \"CONCERT\"\r\n                festival: boolean\r\n                nearUser: boolean\r\n                venue: {\r\n                    name: string\r\n                    location: { name: string }\r\n                    coordinates: {\r\n                        latitude: number\r\n                        longitude: number\r\n                    }\r\n                }\r\n                partnerLinks: Items<{\r\n                    partnerName: string\r\n                    url: string\r\n                }>\r\n\r\n                date: Date\r\n            }> & {\r\n                pagingInfo: {\r\n                    limit: number\r\n                }\r\n            }\r\n        }\r\n        merch: Items<{\r\n            image: {\r\n                sources: Array<{ url: string }>\r\n            }\r\n            name: string\r\n            description: string\r\n            price: string\r\n            uri: string\r\n            url: string\r\n        }>\r\n    }\r\n}\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistOverview, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n        includePrerelease: true,\r\n    })\r\n\r\n    return res.data.artistUnion as fetchGQLArtistOverviewRes\r\n}\r\n\r\nexport type fetchGQLArtistDiscographyRes = {\r\n    __typename: \"artist\"\r\n    discography: {\r\n        all: ItemsReleases<Item2>\r\n    }\r\n}\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistDiscographyAll, {\r\n        uri,\r\n        offset,\r\n        limit,\r\n    })\r\n\r\n    return res.data.artistUnion as fetchGQLArtistDiscographyRes\r\n}\r\ntype fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n        }\r\n    }\r\n}>\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistRelated, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n    })\r\n\r\n    return res.data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n}\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await spotifyApi.search(name, [\"playlist\"])\r\n    const item = res.playlists.items.find(item => item?.owner.id === \"thesoundsofspotify\" && re.test(item.name))\r\n    return item?.uri\r\n}\r\n\r\n/*                          Last FM                                       */\r\n\r\nexport interface fetchLastFMTrackResMinimal {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\nexport const fetchLastFMTrack = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    const res = (await fetch(url).then(res => res.json())) as fetchLastFMTrackResMinimal\r\n\r\n    return res.track\r\n}\r\n\r\n/*                          Youtube                                       */\r\n\r\nexport interface SearchYoutubeResMinimal {\r\n    items: Array<{\r\n        id: {\r\n            videoId: string\r\n        }\r\n        snippet: {\r\n            publishedAt: string\r\n            channelId: string\r\n            title: string\r\n            description: string\r\n            channelTitle: string\r\n            publishTime: string\r\n        }\r\n    }>\r\n}\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as SearchYoutubeResMinimal\r\n}\r\n\r\n//\r\n\r\nexport type Items<A> = {\r\n    items: Array<A>\r\n}\r\nexport type ItemsWithCount<A> = Items<A> & {\r\n    totalCount: number\r\n}\r\n\r\nexport type ItemsReleases<A> = ItemsWithCount<{\r\n    releases: Items<A>\r\n}>\r\n\r\ntype Date = (\r\n    | {\r\n          year: number\r\n          month?: number\r\n          day?: number\r\n          hour?: number\r\n          mintue?: number\r\n          second?: number\r\n          precision: \"YEAR\"\r\n      }\r\n    | {\r\n          year: number\r\n          month: number\r\n          day?: number\r\n          hour?: number\r\n          mintue?: number\r\n          second?: number\r\n          precision: \"MONTH\"\r\n      }\r\n    | {\r\n          year: number\r\n          month: number\r\n          day: number\r\n          hour?: number\r\n          mintue?: number\r\n          second?: number\r\n          precision: \"DAY\"\r\n      }\r\n    | {\r\n          year: number\r\n          month: number\r\n          day: number\r\n          hour: number\r\n          mintue?: number\r\n          second?: number\r\n          precision: \"HOUR\"\r\n      }\r\n    | {\r\n          year: number\r\n          month: number\r\n          day: number\r\n          hour: number\r\n          mintue: number\r\n          second?: number\r\n          precision: \"MINUTE\"\r\n      }\r\n    | {\r\n          year: number\r\n          month: number\r\n          day: number\r\n          hour: number\r\n          mintue: number\r\n          second: number\r\n          precision: \"SECOND\"\r\n      }\r\n) & {\r\n    isoString: string\r\n}\r\n\r\ntype Playability = {\r\n    playable: boolean\r\n    reason: \"PLAYABLE\" | string\r\n}\r\n\r\nexport type ItemBase = {\r\n    id: string\r\n    uri: string\r\n    name: string\r\n    type: \"SINGLE\" | \"ALBUM\" | \"COMPILATION\" | string\r\n    coverArt: {\r\n        sources: Array<Spicetify.Platform.ImageSized>\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n    }\r\n    playability: Playability\r\n    sharingInfo: {\r\n        shareId: string\r\n        shareUrl: string\r\n    }\r\n}\r\n\r\ntype Item1 = ItemBase & {\r\n    copyright: {\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    date: Date\r\n\r\n    label: string\r\n}\r\n\r\ntype Item2 = ItemBase & {\r\n    date: {\r\n        year: number\r\n        isoString: string\r\n    }\r\n}\r\n\r\nexport type TopTracksItem = {\r\n    uid: string\r\n    track: {\r\n        id: string\r\n        uri: string\r\n        name: string\r\n        playcount: string\r\n        discNumber: number\r\n        duration: {\r\n            totalMilliseconds: number\r\n        }\r\n        playability: Playability\r\n        contentRating: {\r\n            label: \"NONE\" | \"EXPLICIT\"\r\n        }\r\n        artists: Items<{\r\n            uri: string\r\n            profile: {\r\n                name: string\r\n            }\r\n        }>\r\n        albumOfTrack: {\r\n            uri: string\r\n            coverArt: {\r\n                sources: Array<{ url: string }>\r\n            }\r\n        }\r\n    }\r\n}\r\n", "export type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nconst { Player, URI } = Spicetify\r\nconst { PlayerAPI, History } = Spicetify.Platform\r\n\r\nexport const SpotifyLoc = {\r\n    before: {\r\n        start: () => ({ before: \"start\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ before: { uri } }),\r\n        fromUid: (uid: string) => ({ before: { uid } }),\r\n    },\r\n    after: {\r\n        end: () => ({ after: \"end\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ after: { uri } }),\r\n        fromUid: (uid: string) => ({ after: { uid } }),\r\n    },\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E | null,\r\n) =>\r\n    new Promise((resolve: (value: Element) => void, reject) => {\r\n        const onMutation = () => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el) {\r\n                if (notEl && el === notEl) {\r\n                } else {\r\n                    observer.disconnect()\r\n                    return resolve(el)\r\n                }\r\n            }\r\n        }\r\n\r\n        const observer = new MutationObserver(onMutation)\r\n        onMutation()\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout)\r\n            setTimeout(() => {\r\n                observer.disconnect()\r\n                reject()\r\n            }, timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element] as any\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? (\"queue\" as const) : (\"context\" as const),\r\n})\r\n\r\nexport const setQueue = async (\r\n    nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>,\r\n    contextUri?: string,\r\n) => {\r\n    const { _queue, _client } = PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    const res = _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    })\r\n\r\n    contextUri && (await setPlayingContext(contextUri))\r\n\r\n    return res\r\n}\r\n\r\nexport const setPlayingContext = (uri: string) => {\r\n    const { sessionId } = PlayerAPI._state\r\n    return PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri })\r\n}\r\n\r\nexport const onHistoryChanged = (\r\n    toMatchTo: string | RegExp | ((location: string) => boolean),\r\n    callback: (uri: SpotifyURI) => void,\r\n    dropDuplicates = true,\r\n) => {\r\n    const createMatchFn = (toMatchTo: string | RegExp | ((input: string) => boolean)) => {\r\n        switch (typeof toMatchTo) {\r\n            case \"string\":\r\n                return (input: string) => input?.startsWith(toMatchTo) ?? false\r\n\r\n            case \"function\":\r\n                return toMatchTo\r\n\r\n            default:\r\n                return (input: string) => toMatchTo.test(input)\r\n        }\r\n    }\r\n\r\n    let lastPathname = \"\"\r\n    const matchFn = createMatchFn(toMatchTo)\r\n\r\n    const historyChanged = ({ pathname }: any) => {\r\n        if (matchFn(pathname)) {\r\n            if (dropDuplicates && lastPathname === pathname) {\r\n            } else callback(URI.fromString(pathname).toURI())\r\n        }\r\n        lastPathname = pathname\r\n    }\r\n\r\n    historyChanged(History.location ?? {})\r\n    return History.listen(historyChanged)\r\n}\r\n\r\nexport const onSongChanged = (callback: (state?: Spicetify.PlayerState) => void) => {\r\n    callback(Player.data)\r\n    Player.addEventListener(\"songchange\", event => callback(event!.data))\r\n}\r\n", "// @deno-types=\"npm:@types/lodash\"\r\nimport { default as ld } from \"https://esm.sh/lodash\"\r\nexport const _ = ld\r\n\r\n// @deno-types=\"npm:@types/lodash/fp\"\r\nimport { default as ld_fp } from \"https://esm.sh/lodash/fp\"\r\nexport const fp = ld_fp\r\n", "import { _ } from \"./deps.ts\"\r\n\r\nconst { Snackbar } = Spicetify\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const chunkify50 =\r\n    <A, R>(fn: (a: Array<A>) => R) =>\r\n    async (args: Array<A>) => {\r\n        const a = await Promise.all(_.chunk(args, 50).map(fn))\r\n        return a.flat()\r\n    }\r\n\r\nexport const progressify = <F extends (...args: any) => any>(f: F, n: number) => {\r\n    let i = n,\r\n        lastProgress = 0\r\n    return async function (..._: Parameters<F>): Promise<Awaited<ReturnType<F>>> {\r\n        const res = (await f(...arguments)) as Awaited<ReturnType<F>>,\r\n            progress = Math.round((1 - --i / n) * 100)\r\n        if (progress > lastProgress) {\r\n            ;(Snackbar as any).updater.enqueueSetState(Snackbar, () => ({\r\n                snacks: [],\r\n                queue: [],\r\n            }))\r\n            Snackbar.enqueueSnackbar(`Loading: ${progress}%`, {\r\n                variant: \"default\",\r\n                autoHideDuration: 200,\r\n                transitionDuration: {\r\n                    enter: 0,\r\n                    exit: 0,\r\n                },\r\n            })\r\n        }\r\n        lastProgress = progress\r\n        return res\r\n    }\r\n}\r\n", "import { Track } from \"https://esm.sh/v135/@fostertheweb/spotify-web-api-ts-sdk/dist/mjs/types.js\"\r\n\r\nimport { searchGQL } from \"../../shared/GraphQL/searchModalResults.ts\"\r\nimport { spotifyApi } from \"../../shared/api.ts\"\r\nimport { chunkify50 } from \"../../shared/fp.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nconst SEP = \":\"\r\nconst LS_PREFIX = [\"extensions\", \"detect-duplicates\"]\r\nconst LS_KEY_INDEX = LS_PREFIX.join(SEP).length + 1\r\n\r\nconst uriToISRC = new Map(\r\n    Object.values<[string, string]>(localStorage)\r\n        .filter(([key]) => key.startsWith(LS_PREFIX.join(SEP)))\r\n        .flatMap(([key, value]) => {\r\n            const isrc = key.slice(LS_KEY_INDEX)\r\n            const uris = JSON.parse(value) as string[]\r\n            return uris.map(uri => [uri, isrc])\r\n        }),\r\n)\r\n\r\nconst getLSKey = (isrc: string) => [...LS_PREFIX, isrc].join(SEP)\r\n\r\nconst getISRCUris = (isrc: string) => {\r\n    const key = getLSKey(isrc)\r\n    const urisAsJson = localStorage.getItem(key)\r\n    return urisAsJson ? (JSON.parse(urisAsJson) as string[]) : null\r\n}\r\n\r\nconst setISRCUris = async (isrc: string, uris: string[]) => {\r\n    const getTrackReleaseDate = (a: Track) => new Date(a.album.release_date)\r\n\r\n    const key = getLSKey(isrc)\r\n    const ids = uris.map(uri => URI.fromString(uri)!.id!)\r\n    const tracks = await spotifyApi.tracks.get(ids)\r\n    //@ts-expect-error: ts dumb, ts can't substract dates\r\n    const sortedTracks = tracks.sort((a, b) => getTrackReleaseDate(b) - getTrackReleaseDate(a))\r\n    const sortedUris = sortedTracks.map(track => track.uri)\r\n    const value = JSON.stringify(sortedUris)\r\n    localStorage.setItem(key, value)\r\n    return sortedUris\r\n}\r\n\r\nexport const getUrisFromISRC = async (isrc: string) => {\r\n    const cachedUris = getISRCUris(isrc)\r\n    if (!cachedUris) {\r\n        const results = await searchGQL(`isrc:${isrc}`)\r\n        const uris = results.map(i => i.item.data.uri)\r\n        return await setISRCUris(isrc, uris)\r\n    }\r\n    return cachedUris\r\n}\r\n\r\nexport const getISRCsForUris = async (uris: string[]) => {\r\n    const indicesForCacheMiss = new Array<number>()\r\n    const isrcs = uris.map((uri, i) => (uriToISRC.has(uri) ? uriToISRC.get(uri) : void indicesForCacheMiss.push(i)))\r\n\r\n    const urisForCacheMiss = indicesForCacheMiss.map(i => uris[i])\r\n    const idsForCacheMiss = urisForCacheMiss.map(uri => URI.fromString(uri)!.id!)\r\n    const tracksForCacheMiss = await chunkify50(is => spotifyApi.tracks.get(is))(idsForCacheMiss)\r\n    const isrcsForCacheMiss = tracksForCacheMiss.map(track => track.external_ids.isrc)\r\n\r\n    isrcsForCacheMiss.forEach((isrc, i) => (isrcs[indicesForCacheMiss[i]] = isrc))\r\n\r\n    return isrcs as string[]\r\n}\r\n\r\nexport const isUriOutdatedDuplicate = async (uri: string) => {\r\n    const isrc = uriToISRC.get(uri)\r\n    if (!isrc) return null // cache miss, shouldn't happen as we have made a pass to load the cache\r\n    const [mostRecentUri] = await getUrisFromISRC(isrc)\r\n    return uri !== mostRecentUri\r\n}\r\n", "import { getTrackLists, getTrackListTrackUri, getTrackListTracks } from \"../star-ratings-2/util.ts\"\r\nimport { getISRCsForUris, isUriOutdatedDuplicate } from \"./util.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\ndebugger\r\n\r\nconst greyOutTrack = (track: HTMLDivElement) => {\r\n    track.style.backgroundColor = \"gray\"\r\n    track.style.opacity = \"0.3\"\r\n}\r\n\r\nconst onMutation = async () => {\r\n    const trackLists = getTrackLists()\r\n\r\n    // First pass to load the cache\r\n    {\r\n        const urisByTrackLists = trackLists.map(trackList => {\r\n            const tracks = getTrackListTracks(trackList)\r\n\r\n            return tracks.map(track => URI.fromString(getTrackListTrackUri(track)).toURI())\r\n        })\r\n\r\n        await getISRCsForUris(urisByTrackLists.flat())\r\n    }\r\n\r\n    trackLists.map(trackList => {\r\n        const tracks = getTrackListTracks(trackList)\r\n\r\n        tracks.map(async track => {\r\n            const uri = URI.fromString(getTrackListTrackUri(track)).toURI()\r\n            const isDuplicate = await isUriOutdatedDuplicate(uri)\r\n\r\n            isDuplicate && greyOutTrack(track)\r\n        })\r\n    })\r\n}\r\n\r\nlet mainElement: HTMLElement\r\nconst mainElementObserver = new MutationObserver(() => onMutation())\r\n\r\nnew MutationObserver(() => {\r\n    const nextMainElement = document.querySelector<HTMLElement>(\"main\")\r\n    if (nextMainElement && !nextMainElement.isEqualNode(mainElement)) {\r\n        if (mainElement) mainElementObserver.disconnect()\r\n        mainElement = nextMainElement\r\n        mainElementObserver.observe(mainElement, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n    }\r\n}).observe(document.body, {\r\n    childList: true,\r\n    subtree: true,\r\n})\r\n"],
  "mappings": "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",
  "names": ["GraphQL", "URI", "URI"]
}
