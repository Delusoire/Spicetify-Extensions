{
  "version": 3,
  "sources": ["../../shared/fp.ts", "../../shared/util.ts", "../../shared/api.ts", "../../extensions/keyboard-shortcuts/sneak.ts", "../../extensions/keyboard-shortcuts/util.ts", "../../extensions/keyboard-shortcuts/app.ts"],
  "sourcesContent": ["import {\r\n    array as ar,\r\n    eq,\r\n    string as str,\r\n    record as rec,\r\n    refinement as ref,\r\n    semigroup as sg,\r\n    function as f,\r\n} from \"https://esm.sh/fp-ts\"\r\nimport { guard, memoize } from \"https://esm.sh/fp-ts-std/Function\"\r\n\r\ntype refineBranch<A, B extends A, R> = [ref.Refinement<A, B>, (x: B) => R]\r\nexport const guard2 = <A, A1 extends A, A2 extends A, R>(branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>]) =>\r\n    guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>])\r\nexport const guard3 = <A, A1 extends A, A2 extends A, A3 extends A, R>(\r\n    branches: [refineBranch<A, A1, R>, refineBranch<A, A2, R>, refineBranch<A, A3, R>],\r\n) => guard(branches as unknown as [refineBranch<A, A, R>, refineBranch<A, A, R>, refineBranch<A, A, R>])\r\n\r\nexport const objConcat2 = <A1, A2>() => rec.getUnionSemigroup(sg.first<any>()).concat as (x: A1, y: A2) => A1 & A2\r\nexport const objConcat = <A>() => ar.reduce({} as A, objConcat2<A, A>())\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const is =\r\n    <A>(c: keyof A) =>\r\n    <B extends A>(a: A[typeof c]) =>\r\n    (field: A): field is B =>\r\n        field[c] === a\r\n\r\nexport const tapAny =\r\n    <A>(f: (a: A) => void) =>\r\n    (fa: A) => {\r\n        f(fa)\r\n        return fa\r\n    }\r\n\r\nexport const chunckify =\r\n    (n: number) =>\r\n    <A, R>(g: (a: A[]) => Promise<R[]>) =>\r\n        f.flow(ar.chunksOf(n)<A>, ar.map(g), ps => Promise.all(ps), pMchain(ar.flatten))\r\n\r\nexport const withProgress =\r\n    <F extends (f: (...a: any) => any) => (fa: any) => any>(map: F) =>\r\n    (f: Parameters<F>[0]) =>\r\n    (fa: Parameters<ReturnType<F>>[0]): ReturnType<ReturnType<F>> => {\r\n        let i = 0\r\n        return map(async (...a: Parameters<Parameters<F>[0]>) => {\r\n            // @ts-expect-error: Fuck me\r\n            const ret = await f(...a)\r\n            const progress = Math.round((i++ / Object.values(fa).length) * 100)\r\n            Spicetify.showNotification(`Loading: ${progress}%`, false, 200)\r\n            return ret\r\n        })(fa)\r\n    }\r\n\r\nexport const memoize2 = <A extends any[], R>(fn: (...args: A) => R) =>\r\n    f.pipe(fn, f.tupled, memoize<A>(eq.contramap(JSON.stringify)(str.Eq)), f.untupled)\r\n", "import { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\nexport type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nexport type SpotifyLocObj = {\r\n    before?: \"start\" | { uri: SpotifyURI } | { uid: string }\r\n    after?: \"end\" | { uri: SpotifyURI } | { uid: string }\r\n}\r\n\r\nexport const SpotifyLoc = {\r\n    before: {\r\n        start: f.constant({ before: \"start\" } as SpotifyLocObj),\r\n        fromUri: (uri: SpotifyURI) => ({ before: { uri } }),\r\n        fromUid: (uid: string) => ({ before: { uid } }),\r\n    },\r\n    after: {\r\n        end: f.constant({ after: \"end\" } as SpotifyLocObj),\r\n        fromUri: (uri: SpotifyURI) => ({ after: { uri } }),\r\n        fromUid: (uid: string) => ({ after: { uid } }),\r\n    },\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const titleCase = (str: string) => str.replace(/\\b\\w/g, l => l.toUpperCase())\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E,\r\n) =>\r\n    new Promise((resolve: (value: Element) => void, reject) => {\r\n        const onMutation = () => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el) {\r\n                if (notEl && el === notEl) {\r\n                } else {\r\n                    observer.disconnect()\r\n                    return resolve(el)\r\n                }\r\n            }\r\n        }\r\n\r\n        const observer = new MutationObserver(onMutation)\r\n        onMutation()\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout)\r\n            setTimeout(() => {\r\n                observer.disconnect()\r\n                reject()\r\n            }, timeout)\r\n    })\r\n\r\nexport const trapElement = <E extends Element>(\r\n    selector: string,\r\n    callback: (el: E | null, lastEl: E | null) => void,\r\n    location = document.body,\r\n) => {\r\n    let lastEl: E | null = null\r\n\r\n    const observer = new MutationObserver(() => {\r\n        const el = document.querySelector<E>(selector)\r\n        if (el !== lastEl) callback(el, lastEl)\r\n        lastEl = el\r\n    })\r\n\r\n    observer.observe(location, {\r\n        childList: true,\r\n        subtree: true,\r\n    })\r\n}\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element]\r\n\r\nexport const createQueueItem = (queued: boolean) => (uri: SpotifyURI) => ({\r\n    contextTrack: {\r\n        uri,\r\n        uid: \"\",\r\n        metadata: {\r\n            is_queued: queued.toString(),\r\n        },\r\n    },\r\n    removed: [],\r\n    blocked: [],\r\n    provider: queued ? \"queue\" : \"context\",\r\n})\r\n\r\nexport const setQueue = async (nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>) => {\r\n    const { _queue, _client } = Spicetify.Platform.PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    return _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    }) as Promise<{ error: number; reasons: string }>\r\n}\r\n\r\nexport const setPlayingContext = (uri: SpotifyURI) => {\r\n    const { sessionId } = Spicetify.Platform.PlayerAPI.getState()\r\n    return Spicetify.Platform.PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri }) as Promise<undefined>\r\n}\r\n\r\nexport const onHistoryChanged = (\r\n    toMatchTo: string | RegExp | ((location: string) => boolean),\r\n    callback: (uri: SpotifyURI) => void,\r\n    dropDuplicates = true,\r\n) => {\r\n    const createMatchFn = (toMatchTo: string | RegExp | ((input: string) => boolean)) => {\r\n        switch (typeof toMatchTo) {\r\n            case \"string\":\r\n                return (input: string) => input?.startsWith(toMatchTo) ?? false\r\n\r\n            case \"function\":\r\n                return toMatchTo\r\n\r\n            default:\r\n                return (input: string) => toMatchTo.test(input)\r\n        }\r\n    }\r\n\r\n    let lastPathname = \"\"\r\n    const matchFn = createMatchFn(toMatchTo)\r\n\r\n    const historyChanged = ({ pathname }: any) => {\r\n        if (matchFn(pathname)) {\r\n            if (dropDuplicates && lastPathname === pathname) {\r\n            } else callback(Spicetify.URI.fromString(pathname).toString())\r\n        }\r\n        lastPathname = pathname\r\n    }\r\n\r\n    historyChanged(Spicetify.Platform.History.location ?? {})\r\n    Spicetify.Platform.History.listen(historyChanged)\r\n}\r\n\r\nexport const onSongChanged = (callback: (data?: Spicetify.PlayerState) => void) => {\r\n    callback(Spicetify.Player.data)\r\n    Spicetify.Player.addEventListener(\"songchange\", event => callback(event!.data))\r\n}\r\n", "import { chunckify, memoize2 } from \"./fp.ts\"\r\nimport { SpotifyID, SpotifyLocObj, SpotifyURI, escapeRegex } from \"./util.ts\"\r\nimport { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\n/*                          GraphQL                                           */\r\n\r\nexport const fetchGQLAlbum = async (uri: SpotifyURI, offset = 0, limit = 487) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.getAlbum, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.albumUnion as fetchGQLAlbumRes\r\n\r\ntype fetchArtistGQLRes = any\r\nexport const fetchGQLArtistOverview = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistOverview, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n            includePrerelease: true,\r\n        })\r\n    ).data.artistUnion as fetchArtistGQLRes\r\n\r\ntype fetchGQLArtistDiscographyRes = any\r\nexport const fetchGQLArtistDiscography = async (uri: SpotifyURI, offset = 0, limit = 116) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistDiscographyAll, {\r\n            uri,\r\n            offset,\r\n            limit,\r\n        })\r\n    ).data.artistUnion.discography.all.items as fetchGQLArtistDiscographyRes\r\n\r\nexport const fetchGQLArtistRelated = async (uri: SpotifyURI) =>\r\n    (\r\n        await Spicetify.GraphQL.Request(Spicetify.GraphQL.Definitions.queryArtistRelated, {\r\n            uri,\r\n            locale: Spicetify.Locale.getLocale(),\r\n        })\r\n    ).data.artistUnion.relatedContent.relatedArtists.items as fetchGQLArtistRelatedRes\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const removeWebPlaylistTracks = async (playlist: SpotifyID, tracks: SpotifyURI[]) =>\r\n    Spicetify.CosmosAsync.del(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {\r\n        tracks: tracks.map(uri => ({ uri })),\r\n    })\r\n\r\nexport const fetchWebArtistsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/artists?ids=${ids.join(\",\")}`))\r\n            .artists as SpotApiArtist[],\r\n)\r\n\r\nexport const fetchWebPlaylistsSpot = chunckify(1)(\r\n    // @ts-ignore chunkify will never call with empty array\r\n    async ([id]: [SpotifyID]) => [\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/playlists/${id}`)) as SpotApiPlaylist,\r\n    ],\r\n)\r\nexport const fetchWebAlbumsSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/albums?ids=${ids.join(\",\")}`))\r\n            .albums as SpotApiAlbum[],\r\n)\r\n\r\nexport const fetchWebTracksSpot = chunckify(50)(\r\n    async (ids: SpotifyID[]) =>\r\n        (await Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/tracks?ids=${ids.join(\",\")}`))\r\n            .tracks as SpotApiTrack[],\r\n)\r\n\r\nexport const searchWebItemSpot = async (q: string, type: string[]) =>\r\n    Spicetify.CosmosAsync.get(`https://api.spotify.com/v1/search?q=${encodeURIComponent(q)}&type=${type.join(\",\")}`)\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await searchWebItemSpot(name, [\"playlist\"])\r\n    const item = res.playlists.items[0]\r\n    return item?.owner.id === \"thesoundsofspotify\" && re.test(item.name) ? item.uri : null\r\n}\r\n\r\n/*                          Platform                                          */\r\n\r\nexport const isPlatTrackLiked = (uris: SpotifyURI[]) =>\r\n    Spicetify.Platform.LibraryAPI.contains(...uris) as Promise<boolean[]>\r\n\r\nexport const setPlatTrackLiked = (uris: SpotifyURI[], liked: boolean) =>\r\n    Spicetify.Platform.LibraryAPI[liked ? \"add\" : \"remove\"]({ uris })\r\n\r\nexport const togglePlatTrackLiked = async (uris: SpotifyURI[]) => {\r\n    const liked = await isPlatTrackLiked(uris)\r\n\r\n    return await f.pipe(\r\n        uris,\r\n        a.reduceWithIndex(\r\n            [[] as SpotifyURI[], [] as SpotifyURI[]] as const,\r\n            (i, acc, uri) => (acc[Number(liked[i])].push(uri), acc),\r\n        ),\r\n        ([toAdd, toRem]) => {\r\n            const ps = []\r\n            if (toAdd.length) ps.push(setPlatTrackLiked(toAdd, true))\r\n            if (toRem.length) ps.push(setPlatTrackLiked(toRem, false))\r\n            return Promise.all(ps)\r\n        },\r\n    )\r\n}\r\n\r\nexport const fetchPlatLikedTracks = async () =>\r\n    (\r\n        await Spicetify.Platform.LibraryAPI.getTracks({\r\n            limit: Number.MAX_SAFE_INTEGER,\r\n        })\r\n    ).items as fetchPlatArtistLikedTracksRes\r\nexport const fetchPlatArtistLikedTracks = async (uri: SpotifyURI, offset = 0, limit = 100) =>\r\n    (await Spicetify.Platform.LibraryAPI.getTracks({ uri, offset, limit })).items as fetchPlatArtistLikedTracksRes\r\n\r\nexport const fetchPlatPlaylistContents = async (uri: SpotifyURI) =>\r\n    (await Spicetify.Platform.PlaylistAPI.getContents(uri)).items as fetchWebPlaylistRes\r\n\r\nexport const createPlatFolder = async (name: string, location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createFolder(name, location)\r\n\r\nexport const addPlatPlaylist = async (playlist: SpotifyURI, folder?: SpotifyURI, addedAt = new Date()) =>\r\n    await Spicetify.Platform.RootlistAPI.add([playlist], { after: { type: \"folder\", addedAt, uri: folder } })\r\n\r\n/* Replaced by createSPPlaylistFromTracks */\r\nexport const createPlatPlaylist = async (name: string, location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.RootlistAPI.createPlaylist(name, location)\r\n\r\nexport const createSPPlaylistFromTracks = (name: string, tracks: SpotifyURI[], folder?: SpotifyURI) =>\r\n    Spicetify.CosmosAsync.post(\"sp://core-playlist/v1/rootlist?responseFormat=protobufJson\", {\r\n        operation: \"create\",\r\n        ...(folder ? { after: folder } : {}),\r\n        name,\r\n        playlist: true,\r\n        uris: tracks,\r\n    })\r\n\r\nexport const setPlatPlaylistVisibility = async (playlist: SpotifyURI, visibleForAll: boolean) =>\r\n    await Spicetify.Platform.PlaylistPermissionsAPI.setBasePermission(playlist, visibleForAll ? \"VIEWER\" : \"BLOCKED\")\r\nexport const setPlatPlaylistPublished = async (playlist: SpotifyURI, published: boolean) =>\r\n    await Spicetify.Platform.RootlistAPI.setPublishedState(playlist, published)\r\n\r\nexport const fetchPlatFolder = async (folder?: SpotifyURI) =>\r\n    (await Spicetify.Platform.RootlistAPI.getContents({ folderUri: folder })) as fetchPlatFolderRes\r\nexport const fetchPlatRootFolder = () => fetchPlatFolder(undefined)\r\n\r\nexport const addPlatPlaylistTracks = async (playlist: SpotifyURI, tracks: SpotifyURI[], location: SpotifyLocObj = {}) =>\r\n    await Spicetify.Platform.PlaylistAPI.add(playlist, tracks, location)\r\n\r\nexport const movePlatPlaylistTracks = async (\r\n    playlist: SpotifyURI,\r\n    tracks: Array<{ uid: string }>,\r\n    location: SpotifyLocObj = {},\r\n) => await Spicetify.Platform.PlaylistAPI.move(playlist, tracks, location)\r\n\r\nexport const removePlatPlaylistTracks = async (playlist: SpotifyURI, tracks: Array<{ uid: string }>) =>\r\n    Spicetify.Platform.PlaylistAPI.remove(playlist, tracks)\r\n\r\nexport const fetchPlatPlaylistEnhancedSongs300 = async (uri: SpotifyURI, offset = 0, limit = 300) =>\r\n    (await Spicetify.Platform.EnhanceAPI.getPage(uri, /* iteration */ 0, /* sessionId */ 0, offset, limit)).enhancePage\r\n        .pageItems as any[]\r\nexport const fetchPlatPlaylistEnhancedSongs = async (uri: SpotifyURI, offset = 0): Promise<any[]> => {\r\n    const nextPageItems = await fetchPlatPlaylistEnhancedSongs300(uri, offset)\r\n    if (nextPageItems?.length < 300) return nextPageItems\r\n    else return nextPageItems.concat(fetchPlatPlaylistEnhancedSongs(uri, offset + 300))\r\n}\r\n\r\nexport const fetchLocalTracks = async () => await Spicetify.Platform.LocalFilesAPI.getTracks()\r\n\r\n/*                          Non Spotify                                       */\r\n\r\nexport const fetchTrackLFMAPI = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    return (await fetch(url).then(res => res.json())) as fetchTrackLFMAPIRes\r\n}\r\n\r\nexport const fetchTrackLFMAPIMemoized = memoize2(fetchTrackLFMAPI)\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as any[]\r\n}\r\n\r\n/*                          Types                                             */\r\n\r\nexport interface fetchGQLAlbumRes {\r\n    __typename: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artists: {\r\n        totalCount: number\r\n        items: Array<{\r\n            id: string\r\n            uri: SpotifyURI\r\n            profile: {\r\n                name: string\r\n            }\r\n            visuals: {\r\n                avatarImage: {\r\n                    sources: SpotApiImage[]\r\n                }\r\n            }\r\n            sharingInfo: {\r\n                shareUrl: string\r\n            }\r\n        }>\r\n    }\r\n    coverArt: {\r\n        extractedColors: {\r\n            colorRaw: {\r\n                hex: string\r\n            }\r\n            colorLight: {\r\n                hex: string\r\n            }\r\n            colorDark: {\r\n                hex: string\r\n            }\r\n        }\r\n        sources: SpotApiImage[]\r\n    }\r\n    discs: {\r\n        totalCount: number\r\n        items: Array<{\r\n            number: number\r\n            tracks: {\r\n                totalCount: number\r\n            }\r\n        }>\r\n    }\r\n    releases: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uri: SpotifyURI\r\n            name: string\r\n        }>\r\n    }\r\n    type: string\r\n    date: {\r\n        isoString: string\r\n        precision: string\r\n    }\r\n    playability: {\r\n        playable: boolean\r\n        reason: string\r\n    }\r\n    label: string\r\n    copyright: {\r\n        totalCount: number\r\n        items: Array<{\r\n            type: string\r\n            text: string\r\n        }>\r\n    }\r\n    courtesyLine: string\r\n    saved: boolean\r\n    sharingInfo: {\r\n        shareUrl: string\r\n        shareId: string\r\n    }\r\n    tracks: {\r\n        totalCount: number\r\n        items: Array<{\r\n            uid: string\r\n            track: {\r\n                saved: boolean\r\n                uri: SpotifyURI\r\n                name: string\r\n                playcount: string\r\n                discNumber: number\r\n                trackNumber: number\r\n                contentRating: {\r\n                    label: string\r\n                }\r\n                relinkingInformation: any\r\n                duration: {\r\n                    totalMilliseconds: number\r\n                }\r\n                playability: {\r\n                    playable: boolean\r\n                }\r\n                artists: {\r\n                    items: Array<{\r\n                        uri: SpotifyURI\r\n                        profile: {\r\n                            name: string\r\n                        }\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n    moreAlbumsByArtist: {\r\n        items: Array<{\r\n            discography: {\r\n                popularReleasesAlbums: {\r\n                    items: Array<{\r\n                        id: string\r\n                        uri: SpotifyURI\r\n                        name: string\r\n                        date: {\r\n                            year: number\r\n                        }\r\n                        coverArt: {\r\n                            sources: SpotApiImage[]\r\n                        }\r\n                        playability: {\r\n                            playable: boolean\r\n                            reason: string\r\n                        }\r\n                        sharingInfo: {\r\n                            shareId: string\r\n                            shareUrl: string\r\n                        }\r\n                        type: string\r\n                    }>\r\n                }\r\n            }\r\n        }>\r\n    }\r\n}\r\n\r\nexport type fetchGQLArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: SpotifyURI\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: SpotApiImage[]\r\n        }\r\n    }\r\n}>\r\n\r\nexport type fetchPlatArtistLikedTracksRes = Array<{\r\n    type: string\r\n    uri: string\r\n    name: string\r\n    duration: SpotApiDuration\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    isExplicit: boolean\r\n    isPlayable: boolean\r\n    isLocal: boolean\r\n    is19PlusOnly: boolean\r\n    addedAt: string\r\n}>\r\n\r\nexport type fetchWebPlaylistRes = Array<{\r\n    uid: string\r\n    playIndex: null\r\n    addedAt: string\r\n    addedBy: {\r\n        type: string\r\n        uri: SpotifyURI\r\n        username: string\r\n        displayName: string\r\n        images: SpotApiImage2[]\r\n    }\r\n    formatListAttributes: {}\r\n    type: \"track\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    album: SpotApiAlbumMin\r\n    artists: SpotApiArtistMin[]\r\n    discNumber: number\r\n    trackNumber: number\r\n    duration: SpotApiDuration\r\n    isExplicit: boolean\r\n    isLocal: boolean\r\n    isPlayable: boolean\r\n    is19PlusOnly: boolean\r\n}>\r\n\r\nexport interface fetchTrackLFMAPIRes {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        streamable: {\r\n            \"#text\": string\r\n            fulltrack: string\r\n        }\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n            image: Array<{\r\n                \"#text\": string\r\n                size: string\r\n            }>\r\n            \"@attr\": {\r\n                position: string\r\n            }\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\n//\r\n\r\nexport interface SpotApiAlbumMin {\r\n    type: \"album\"\r\n    uri: SpotifyURI\r\n    name: string\r\n    artist: SpotApiArtistMin\r\n    images: SpotApiImage2[]\r\n}\r\n\r\nexport interface SpotApiImage2 {\r\n    url: string\r\n    label: \"small\" | \"standard\" | \"large\" | \"xlarge\"\r\n}\r\n\r\nexport interface SpotApiTrack {\r\n    album: SpotApiAlbum\r\n    artists: SpotApiArtist[]\r\n    available_markets: string[]\r\n    disc_number: number\r\n    duration_ms: number\r\n    explicit: boolean\r\n    external_ids: SpotApiEIDs\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    is_playable: boolean\r\n    linked_from: {}\r\n    restrictions: SpotApiRestrictions\r\n    name: string\r\n    popularity: number\r\n    preview_url: string\r\n    track_number: number\r\n    type: string\r\n    uri: SpotifyURI\r\n    is_local: boolean\r\n}\r\n\r\nexport interface SpotApiArtist {\r\n    external_urls: SpotApiEUrls\r\n    followers: SpotApiFollowers\r\n    genres: string[]\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    popularity: number\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiArtistMin {\r\n    type: \"artist\"\r\n    uri: SpotifyURI\r\n    name: string\r\n}\r\n\r\nexport interface SpotApiAlbum {\r\n    album_type: string\r\n    total_tracks: number\r\n    available_markets: string[]\r\n    external_urls: SpotApiEUrls\r\n    href: string\r\n    id: string\r\n    images: SpotApiImage[]\r\n    name: string\r\n    release_date: string\r\n    release_date_precision: string\r\n    restrictions: SpotApiRestrictions\r\n    type: string\r\n    uri: SpotifyURI\r\n    copyrights: Array<{\r\n        text: string\r\n        type: string\r\n    }>\r\n    external_ids: SpotApiEIDs\r\n    genres: string[]\r\n    label: string\r\n    popularity: number\r\n    album_group: string\r\n    artists: Array<{\r\n        external_urls: SpotApiEUrls\r\n        href: string\r\n        id: string\r\n        name: string\r\n        type: string\r\n        uri: SpotifyURI\r\n    }>\r\n}\r\n\r\nexport interface SpotApiEUrls {\r\n    spotify: string\r\n}\r\n\r\nexport interface SpotApiEIDs {\r\n    isrc: string\r\n    ean: string\r\n    upc: string\r\n}\r\n\r\nexport interface SpotApiImage {\r\n    url: string\r\n    width: number\r\n    height: number\r\n}\r\n\r\nexport interface SpotApiRestrictions {\r\n    reason: string\r\n}\r\n\r\nexport interface SpotApiFollowers {\r\n    href: string\r\n    total: number\r\n}\r\nexport interface SpotApiDuration {\r\n    milliseconds: number\r\n}\r\nexport interface SpotApiPlaylist {\r\n    collaborative: boolean\r\n    description: string\r\n    external_urls: SpotApiEUrls\r\n    followers: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    images: SpotApiImage[]\r\n    name: string\r\n    owner: SpotApiOwner\r\n    public: boolean\r\n    snapshot_id: string\r\n    tracks: {\r\n        href: string\r\n        limit: number\r\n        next: string\r\n        offset: number\r\n        previous: string\r\n        total: number\r\n        items: Array<{\r\n            added_at: string\r\n            added_by: SpotApiOwner\r\n            is_local: boolean\r\n            track: SpotApiTrack\r\n        }>\r\n    }\r\n    type: string\r\n    uri: SpotifyURI\r\n}\r\n\r\nexport interface SpotApiOwner {\r\n    external_urls: SpotApiEUrls\r\n    followers?: {\r\n        href: string\r\n        total: number\r\n    }\r\n    href: string\r\n    id: SpotifyID\r\n    type: string\r\n    uri: SpotifyURI\r\n    display_name?: string\r\n    name?: string\r\n}\r\n\r\n//TODO: Better TS interface for recursive fetchPlatFolderRes\r\nexport interface fetchPlatFolderRes {\r\n    type: \"folder\" | \"placeholder\" | \"playlist\"\r\n    addedAt: string\r\n    items?: Array<fetchPlatFolderRes>\r\n    name?: string\r\n    uri: string\r\n    description?: string\r\n    images?: SpotApiImage2[]\r\n    madeFor?: null\r\n    owner?: {\r\n        type: \"user\"\r\n        uri: string\r\n        username: string\r\n        displayName: string\r\n        images: any[]\r\n    }\r\n    totalLength?: number\r\n    unfilteredTotalLength?: number\r\n    totalLikes?: null\r\n    duration?: null\r\n    isCollaborative?: boolean\r\n    isLoaded?: boolean\r\n    isOwnedBySelf?: boolean\r\n    isPublished?: boolean\r\n    hasEpisodes?: null\r\n    hasSpotifyTracks?: null\r\n    hasSpotifyAudiobooks?: null\r\n    canAdd?: boolean\r\n    canRemove?: boolean\r\n    canPlay?: null\r\n    formatListData?: {\r\n        type: string\r\n        attributes: { [key: string]: string }\r\n    } | null\r\n    canReportAnnotationAbuse?: boolean\r\n    hasDateAdded?: boolean\r\n    permissions?: null\r\n    collaborators?: {\r\n        count: number\r\n        items: any[]\r\n    }\r\n    isNotFound?: boolean\r\n    isForbidden?: boolean\r\n}\r\n", "import { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\nimport { LitElement, css, html } from \"https://esm.sh/lit\"\r\nimport { customElement, property } from \"https://esm.sh/lit/decorators.js\"\r\nimport { map } from \"https://esm.sh/lit/directives/map.js\"\r\nimport { styleMap } from \"https://esm.sh/lit/directives/style-map.js\"\r\nimport { CLICKABLE_ELMENT_SELECTOR, isElementInViewPort, isElementVisible } from \"./util.ts\"\r\n\r\nexport const mousetrapInst = Spicetify.Mousetrap()\r\nexport const KEY_LIST = \"abcdefghijklmnopqrstuvwxyz\".split(\"\")\r\n\r\nexport let listeningToSneakBinds = false\r\n\r\n@customElement(\"sneak-key\")\r\nclass _SneakKey extends LitElement {\r\n    @property()\r\n    key = \"None\"\r\n\r\n    @property()\r\n    target = document.body\r\n\r\n    protected render() {\r\n        const { x, y } = this.target.getBoundingClientRect()\r\n        const styles = {\r\n            position: \"fixed\",\r\n            padding: \"3px 6px\",\r\n            backgroundColor: \"black\",\r\n            borderRadius: \"3px\",\r\n            border: \"solid 2px white\",\r\n            color: \"white\",\r\n            textTransform: \"lowercase\",\r\n            lineHeight: \"normal\",\r\n            fontSize: \"14px\",\r\n            fontWeight: \"500\",\r\n            top: y + \"px\",\r\n            left: x + \"px\",\r\n        }\r\n        return html`<span style=${styleMap(styles)}>${this.key}</span>`\r\n    }\r\n}\r\n\r\n@customElement(\"sneak-overlay\")\r\nexport class _SneakOverlay extends LitElement {\r\n    static styles = css`\r\n        :host {\r\n            z-index: 1e5;\r\n            position: absolute;\r\n            width: 100%;\r\n            height: 100%;\r\n            display: block;\r\n        }\r\n    `\r\n\r\n    @property()\r\n    props = [] as Array<{ key: string; target: HTMLElement }>\r\n\r\n    constructor() {\r\n        super()\r\n\r\n        requestAnimationFrame(() => {\r\n            let k1 = 0,\r\n                k2 = 0\r\n\r\n            this.props = f.pipe(\r\n                Array.from(document.querySelectorAll<HTMLElement>(CLICKABLE_ELMENT_SELECTOR)),\r\n                a.filter(isElementVisible),\r\n                a.filter(isElementInViewPort),\r\n                a.map(target => {\r\n                    const key = KEY_LIST[k1] + KEY_LIST[k2++]\r\n                    if (k2 >= KEY_LIST.length) k1++, (k2 = 0)\r\n                    return { target, key }\r\n                }),\r\n            )\r\n\r\n            if (k1 + k2 === 0) this.remove()\r\n            else listeningToSneakBinds = true\r\n        })\r\n    }\r\n\r\n    disconnectedCallback() {\r\n        super.disconnectedCallback()\r\n        listeningToSneakBinds = false\r\n    }\r\n\r\n    updateProps(key: KeyboardEvent[\"key\"]) {\r\n        if (!listeningToSneakBinds) return\r\n\r\n        this.props = this.props.filter(prop => {\r\n            const [k1, ...ks] = prop.key.toLowerCase()\r\n            if (k1 !== key) return false\r\n            prop.key = ks.join(\"\")\r\n            return true\r\n        })\r\n        if (this.props.length === 1) this.props[0].target.click()\r\n        if (this.props.length < 2) this.remove()\r\n    }\r\n\r\n    protected render() {\r\n        return html`${map(this.props, i => html`<sneak-key key=${i.key} .target=${i.target} />`)}`\r\n    }\r\n}\r\n\r\ndeclare global {\r\n    interface HTMLElementTagNameMap {\r\n        \"sneak-key\": _SneakKey\r\n        \"sneak-overlay\": _SneakOverlay\r\n    }\r\n}\r\n", "import { function as f, number as n, ord } from \"https://esm.sh/fp-ts\"\r\nimport { mean } from \"https://esm.sh/fp-ts-std/Array\"\r\nimport { mod } from \"https://esm.sh/fp-ts-std/Number\"\r\nimport { listeningToSneakBinds } from \"./sneak.ts\"\r\n\r\nconst SCROLL_STEP = 25\r\n\r\nconst focusOnApp = () => document.querySelector<Element>(\".Root__main-view .os-viewport\")!\r\n\r\nexport const appScroll = (s: number) => {\r\n    const app = focusOnApp()\r\n    const scrollIntervalId = setInterval(() => (app.scrollTop += s * SCROLL_STEP), 10)\r\n    document.addEventListener(\"keyup\", () => clearInterval(scrollIntervalId))\r\n}\r\n\r\nexport const appScrollY = (y: number) => focusOnApp().scroll(0, y)\r\n\r\nexport const openPage = (page: string) => Spicetify.Platform.History.push({ pathname: page })\r\n\r\nexport const rotateSidebar = (offset: number) => {\r\n    const navLinks = Array.from(\r\n        Array.from(document.querySelectorAll<HTMLElement>(\".main-yourLibraryX-navLink\")).values(),\r\n    )\r\n\r\n    f.pipe(\r\n        document.querySelector(\".main-yourLibraryX-navLinkActive\"),\r\n        active => navLinks.findIndex(e => e === active),\r\n        curr => mod(navLinks.length)(curr === -1 && offset <= 0 ? offset : curr + offset),\r\n        target => navLinks[target].click(),\r\n    )\r\n}\r\n\r\nexport const resizeLeftSidebar = (pxs: number) => {\r\n    const html = document.firstElementChild! as HTMLHtmlElement,\r\n        htmlStyle = html.style\r\n    htmlStyle.cssText = htmlStyle.cssText.replace(/(--left-sidebar-width: )[^;]+/, `$1${pxs}px`)\r\n}\r\n\r\nexport class Bind {\r\n    private ctrl = false\r\n    private shift = false\r\n    private alt = false\r\n    constructor(private key: string, private callback: (event: KeyboardEvent) => void) {}\r\n\r\n    setCtrl = (required: boolean) => ((this.ctrl = required), this)\r\n    setShift = (required: boolean) => ((this.shift = required), this)\r\n    setAlt = (required: boolean) => ((this.alt = required), this)\r\n\r\n    register = () =>\r\n        Spicetify.Keyboard.registerShortcut(\r\n            { key: this.key, ctrl: this.ctrl, shift: this.shift, alt: this.alt },\r\n            event => void (!listeningToSneakBinds && this.callback(event)),\r\n        )\r\n}\r\n\r\nexport const isElementVisible = (e: HTMLElement) => e.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true })\r\nexport const isElementInViewPort = (e: HTMLElement) => {\r\n    const c = document.body\r\n    const bound = e.getBoundingClientRect()\r\n    const within = (m: number, M: number) => (x: number) => x === ord.clamp(n.Ord)(m, M)(x)\r\n    return (\r\n        f.pipe(mean([bound.top, bound.bottom]), within(0, c.clientHeight)) &&\r\n        f.pipe(mean([bound.left, bound.right]), within(0, c.clientWidth))\r\n    )\r\n}\r\n\r\nexport const CLICKABLE_ELMENT_SELECTOR = `.Root__top-container [href]:not(link),.Root__top-container button,.Root__top-container [role=\"button\"]`\r\n", "import { togglePlatTrackLiked } from \"../../shared/api.ts\"\r\nimport { KEY_LIST, _SneakOverlay, mousetrapInst } from \"./sneak.ts\"\r\nimport { Bind, appScroll, appScrollY, openPage, rotateSidebar } from \"./util.ts\"\r\n\r\nconst { KEYS } = Spicetify.Keyboard\r\n\r\nlet sneakOverlay: _SneakOverlay\r\n\r\nconst binds = [\r\n    new Bind(\"s\", () => {\r\n        sneakOverlay = document.createElement(\"sneak-overlay\")\r\n        document.body.append(sneakOverlay)\r\n    }),\r\n    new Bind(\"s\", async () => {\r\n        // product_state was renamed to product_state_service in Spotify 1.2.21\r\n        const productState =\r\n            Spicetify.Platform.UserAPI._product_state || Spicetify.Platform.UserAPI._product_state_service\r\n        await productState.putValues({ pairs: { \"app-developer\": \"2\" } })\r\n        Spicetify.Platform.UpdateAPI.applyUpdate()\r\n    }).setShift(true),\r\n    new Bind(\"tab\", () => rotateSidebar(1)),\r\n    new Bind(\"tab\", () => rotateSidebar(-1)).setShift(true),\r\n    new Bind(\"h\", Spicetify.Platform.History.goBack).setShift(true),\r\n    new Bind(\"l\", Spicetify.Platform.History.goForward).setShift(true),\r\n    new Bind(\"j\", () => appScroll(1)),\r\n    new Bind(\"k\", () => appScroll(-1)),\r\n    new Bind(\"g\", () => appScrollY(0)),\r\n    new Bind(\"g\", () => appScrollY(Number.MAX_SAFE_INTEGER)).setShift(true),\r\n    new Bind(\r\n        \"m\",\r\n        () =>\r\n            Spicetify.Player.data?.item.currentTrackUri &&\r\n            togglePlatTrackLiked([Spicetify.Player.data?.item.currentTrackUri]),\r\n    ),\r\n    new Bind(\"/\", e => {\r\n        e.preventDefault()\r\n        openPage(\"/search\")\r\n    }),\r\n]\r\n\r\nbinds.map(bind => bind.register())\r\n\r\nmousetrapInst.bind(KEY_LIST, (e: KeyboardEvent) => sneakOverlay.updateProps(e.key), \"keypress\")\r\nmousetrapInst.bind(KEYS.ESCAPE, () => sneakOverlay?.remove())\r\n"],
  "mappings": "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",
  "names": ["f", "n", "f", "a", "f", "f", "a", "a", "f", "f", "f", "f", "f", "a"]
}
