{
  "version": 3,
  "sources": ["../../extensions/show-the-genres/app.ts", "../../shared/api.ts", "../../shared/util.ts", "../../shared/deps.ts", "../../shared/fp.ts", "../../extensions/show-the-genres/settings.ts", "../../shared/settings.tsx", "../../shared/modules.ts", "../../extensions/show-the-genres/components.ts", "../../shared/GraphQL/fetchArtistRelated.ts"],
  "sourcesContent": ["import { array as a, function as f } from \"https://esm.sh/fp-ts\"\r\n\r\nimport { fetchLastFMTrack, spotifyApi } from \"../../shared/api.ts\"\r\nimport { pMchain } from \"../../shared/fp.ts\"\r\nimport { SpotifyURI, onHistoryChanged, onSongChanged, waitForElement } from \"../../shared/util.ts\"\r\n\r\nimport { CONFIG } from \"./settings.ts\"\r\n\r\nimport \"./assets/styles.scss\"\r\nimport \"./components.ts\"\r\nimport { fetchArtistRelated } from \"../../shared/GraphQL/fetchArtistRelated.ts\"\r\n\r\nconst { URI } = Spicetify\r\n\r\nconst fetchLastFMTags = async (uri: SpotifyURI) => {\r\n    const uid = URI.fromString(uri).id!\r\n    const { name, artists } = await spotifyApi.tracks.get(uid)\r\n    const artistNames = artists.map(artist => artist.name)\r\n    const track = await fetchLastFMTrack(CONFIG.LFMApiKey, artistNames[0], name)\r\n    const tags = track.toptags.tag.map(tag => tag.name)\r\n\r\n    const deletedTagRegex = /^-\\d{13}$/\r\n    const blacklistedTags = [\"MySpotigramBot\"]\r\n    return tags.filter(tag => !deletedTagRegex.test(tag) && !blacklistedTags.includes(tag))\r\n}\r\n\r\nconst nowPlayingGenreContainerEl = document.createElement(\"genre-container\")\r\nnowPlayingGenreContainerEl.fetchGenres = fetchLastFMTags\r\nnowPlayingGenreContainerEl.className += \" ellipsis-one-line main-type-finale\"\r\nnowPlayingGenreContainerEl.style.gridArea = \"genres\"\r\n;(async () => {\r\n    const trackInfoContainer = await waitForElement(\"div.main-trackInfo-container\")\r\n    trackInfoContainer!.appendChild(nowPlayingGenreContainerEl)\r\n})()\r\n\r\nonSongChanged(state => (nowPlayingGenreContainerEl.uri = state?.item.uri))\r\n\r\nconst getArtistsGenresOrRelated = async (artistsUris: SpotifyURI[]) => {\r\n    const getArtistsGenres = async (artistsUris: SpotifyURI[]) => {\r\n        const ids = artistsUris.map(uri => URI.fromString(uri)!.id!)\r\n        const artists = await spotifyApi.artists.get(ids)\r\n        const genres = new Set(artists.flatMap(artist => artist.genres))\r\n        return Array.from(genres)\r\n    }\r\n\r\n    const allGenres = await getArtistsGenres(artistsUris)\r\n\r\n    if (allGenres.length) return allGenres\r\n\r\n    const relatedArtists = await fetchArtistRelated(artistsUris[0])\r\n\r\n    relatedArtists.map(artist => artist.uri)\r\n\r\n    return allGenres.length\r\n        ? allGenres\r\n        : await f.pipe(\r\n              artistsUris[0],\r\n              fetchArtistRelated,\r\n              pMchain(a.map(a => a.uri)),\r\n              pMchain(a.chunksOf(5)),\r\n              pMchain(\r\n                  a.reduce(Promise.resolve([] as string[]), async (acc, arr5uris) =>\r\n                      (await acc).length ? await acc : await getArtistsGenres(arr5uris),\r\n                  ),\r\n              ),\r\n          )\r\n}\r\n\r\nconst updateArtistPage = async (uri: SpotifyURI) => {\r\n    const artistGenreContainerEl = document.createElement(\"genre-container\")\r\n    artistGenreContainerEl.name = \"Artist Genres\"\r\n    artistGenreContainerEl.uri = uri.toString()\r\n    artistGenreContainerEl.fetchGenres = uri => getArtistsGenresOrRelated([uri])\r\n\r\n    const lastHeaderTextEl = document.querySelector(\"div.main-entityHeader-headerText\")\r\n    const headerTextEl = await waitForElement(\r\n        \"div.main-entityHeader-headerText\",\r\n        undefined,\r\n        undefined,\r\n        lastHeaderTextEl,\r\n    )\r\n    const headerTextDetailsEl = await waitForElement(\"span.main-entityHeader-detailsText\")\r\n    headerTextEl?.insertBefore(artistGenreContainerEl, headerTextDetailsEl)\r\n}\r\n\r\nonHistoryChanged(uri => URI.isArtist(uri), updateArtistPage)\r\n", "import { AccessToken, SpotifyApi } from \"https://esm.sh/@fostertheweb/spotify-web-api-ts-sdk\"\r\nimport { escapeRegex } from \"./util.ts\"\r\n\r\nconst { CosmosAsync } = Spicetify\r\n\r\nexport const spotifyApi = SpotifyApi.withAccessToken(\"client-id\", {} as AccessToken, {\r\n    // @ts-ignore\r\n    fetch(url, opts) {\r\n        const { method } = opts!\r\n        // @ts-ignore\r\n        return CosmosAsync.resolve(method, url)\r\n    },\r\n    deserializer: {\r\n        deserialize(res) {\r\n            return (res as unknown as Spicetify.CosmosAsync.Response).body\r\n        },\r\n    },\r\n})\r\n\r\n/*                          Spotify Web API                                   */\r\n\r\nexport const fetchWebSoundOfSpotifyPlaylist = async (genre: string) => {\r\n    const name = `The Sound Of ${genre}`\r\n    const re = new RegExp(`^${escapeRegex(name)}$`, \"i\")\r\n    const res = await spotifyApi.search(name, [\"playlist\"])\r\n    const item = res.playlists.items.find(item => item?.owner.id === \"thesoundsofspotify\" && re.test(item.name))\r\n    return item?.uri\r\n}\r\n\r\n/*                          Last FM                                       */\r\n\r\nexport interface fetchLastFMTrackResMinimal {\r\n    track: {\r\n        name: string\r\n        mbid: string\r\n        url: string\r\n        duration: string\r\n        listeners: string\r\n        playcount: string\r\n        artist: {\r\n            name: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        album: {\r\n            artist: string\r\n            title: string\r\n            mbid: string\r\n            url: string\r\n        }\r\n        userplaycount: string\r\n        userloved: string\r\n        toptags: {\r\n            tag: Array<{\r\n                name: string\r\n                url: string\r\n            }>\r\n        }\r\n        wiki: {\r\n            published: string\r\n            summary: string\r\n            content: string\r\n        }\r\n    }\r\n}\r\n\r\nexport const fetchLastFMTrack = async (LFMApiKey: string, artist: string, trackName: string, lastFmUsername = \"\") => {\r\n    const url = new URL(\"https://ws.audioscrobbler.com/2.0/\")\r\n    url.searchParams.append(\"method\", \"track.getInfo\")\r\n    url.searchParams.append(\"api_key\", LFMApiKey)\r\n    url.searchParams.append(\"artist\", artist)\r\n    url.searchParams.append(\"track\", trackName)\r\n    url.searchParams.append(\"format\", \"json\")\r\n    url.searchParams.append(\"username\", lastFmUsername)\r\n\r\n    const res = (await fetch(url).then(res => res.json())) as fetchLastFMTrackResMinimal\r\n\r\n    return res.track\r\n}\r\n\r\n/*                          Youtube                                       */\r\n\r\nexport interface SearchYoutubeResMinimal {\r\n    items: Array<{\r\n        id: {\r\n            videoId: string\r\n        }\r\n        snippet: {\r\n            publishedAt: string\r\n            channelId: string\r\n            title: string\r\n            description: string\r\n            channelTitle: string\r\n            publishTime: string\r\n        }\r\n    }>\r\n}\r\n\r\nexport const searchYoutube = async (YouTubeApiKey: string, searchString: string) => {\r\n    const url = new URL(\"https://www.googleapis.com/youtube/v3/search\")\r\n    url.searchParams.append(\"part\", \"snippet\")\r\n    url.searchParams.append(\"maxResults\", \"10\")\r\n    url.searchParams.append(\"q\", searchString)\r\n    url.searchParams.append(\"type\", \"video\")\r\n    url.searchParams.append(\"key\", YouTubeApiKey)\r\n\r\n    return (await fetch(url).then(res => res.json())) as SearchYoutubeResMinimal\r\n}\r\n", "export type SpotifyID = string\r\nexport type SpotifyURI = string\r\n\r\nconst { Player, URI } = Spicetify\r\nconst { PlayerAPI, History } = Spicetify.Platform\r\n\r\nexport const SpotifyLoc = {\r\n    before: {\r\n        start: () => ({ before: \"start\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ before: { uri } }),\r\n        fromUid: (uid: string) => ({ before: { uid } }),\r\n    },\r\n    after: {\r\n        end: () => ({ after: \"end\" as const }),\r\n        fromUri: (uri: SpotifyURI) => ({ after: { uri } }),\r\n        fromUid: (uid: string) => ({ after: { uid } }),\r\n    },\r\n}\r\n\r\nexport const escapeRegex = (str: string) => str.replace(/[.*+?^${}()|[\\]\\\\]/g, `\\\\$&`)\r\n\r\nexport const normalizeStr = (str: string) =>\r\n    str\r\n        .normalize(\"NFKD\")\r\n        .replace(/\\(.*\\)/g, \"\")\r\n        .replace(/\\[.*\\]/g, \"\")\r\n        .replace(/-_,/g, \" \")\r\n        .replace(/[^a-zA-Z0-9 ]/g, \"\")\r\n        .replace(/\\s+/g, \" \")\r\n        .toLowerCase()\r\n        .trim()\r\n\r\nexport class PermanentMutationObserver extends MutationObserver {\r\n    target: HTMLElement | null = null\r\n\r\n    constructor(targetSelector: string, callback: MutationCallback) {\r\n        super(callback)\r\n        new MutationObserver(() => {\r\n            const nextTarget = document.querySelector<HTMLElement>(targetSelector)\r\n            if (nextTarget && !nextTarget.isEqualNode(this.target)) {\r\n                this.target && this.disconnect()\r\n                this.target = nextTarget\r\n                this.observe(this.target, {\r\n                    childList: true,\r\n                    subtree: true,\r\n                })\r\n            }\r\n        }).observe(document.body, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n    }\r\n}\r\n\r\nexport const waitForElement = <E extends Element>(\r\n    selector: string,\r\n    timeout = 1000,\r\n    location = document.body,\r\n    notEl?: E | null,\r\n) =>\r\n    new Promise((resolve: (value: Element) => void, reject) => {\r\n        const onMutation = () => {\r\n            const el = document.querySelector<E>(selector)\r\n            if (el) {\r\n                if (notEl && el === notEl) {\r\n                } else {\r\n                    observer.disconnect()\r\n                    return resolve(el)\r\n                }\r\n            }\r\n        }\r\n\r\n        const observer = new MutationObserver(onMutation)\r\n        onMutation()\r\n\r\n        observer.observe(location, {\r\n            childList: true,\r\n            subtree: true,\r\n        })\r\n\r\n        if (timeout)\r\n            setTimeout(() => {\r\n                observer.disconnect()\r\n                reject()\r\n            }, timeout)\r\n    })\r\n\r\nexport const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))\r\n\r\nexport const getReactFiber = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactFiber$\")) as keyof typeof element] as any\r\n\r\nexport const getReactProps = (element: Element) =>\r\n    element[Object.keys(element).find(k => k.startsWith(\"__reactProps$\")) as keyof typeof element] as any\r\n\r\nexport const createQueueItem =\r\n    (queued: boolean) =>\r\n    ({ uri, uid = \"\" }: { uri: string; uid?: string }) => ({\r\n        contextTrack: {\r\n            uri,\r\n            uid,\r\n            metadata: {\r\n                is_queued: queued.toString(),\r\n            },\r\n        },\r\n        removed: [],\r\n        blocked: [],\r\n        provider: queued ? (\"queue\" as const) : (\"context\" as const),\r\n    })\r\n\r\nexport const setQueue = async (\r\n    nextTracks: Array<ReturnType<ReturnType<typeof createQueueItem>>>,\r\n    contextUri?: string,\r\n) => {\r\n    const { _queue, _client } = PlayerAPI._queue\r\n    const { prevTracks, queueRevision } = _queue\r\n\r\n    const res = await _client.setQueue({\r\n        nextTracks,\r\n        prevTracks,\r\n        queueRevision,\r\n    })\r\n\r\n    await PlayerAPI.skipToNext()\r\n\r\n    if (contextUri) {\r\n        await new Promise<void>(resolve => {\r\n            PlayerAPI._events.addListener(\"queue_update\", () => resolve(), { once: true })\r\n        })\r\n        await setPlayingContext(contextUri)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nexport const setPlayingContext = (uri: string) => {\r\n    const { sessionId } = PlayerAPI._state\r\n    return PlayerAPI.updateContext(sessionId, { uri, url: \"context://\" + uri })\r\n}\r\n\r\nexport const onHistoryChanged = (\r\n    toMatchTo: string | RegExp | ((location: string) => boolean),\r\n    callback: (uri: SpotifyURI) => void,\r\n    dropDuplicates = true,\r\n) => {\r\n    const createMatchFn = (toMatchTo: string | RegExp | ((input: string) => boolean)) => {\r\n        switch (typeof toMatchTo) {\r\n            case \"string\":\r\n                return (input: string) => input?.startsWith(toMatchTo) ?? false\r\n\r\n            case \"function\":\r\n                return toMatchTo\r\n\r\n            default:\r\n                return (input: string) => toMatchTo.test(input)\r\n        }\r\n    }\r\n\r\n    let lastPathname = \"\"\r\n    const matchFn = createMatchFn(toMatchTo)\r\n\r\n    const historyChanged = ({ pathname }: any) => {\r\n        if (matchFn(pathname)) {\r\n            if (dropDuplicates && lastPathname === pathname) {\r\n            } else callback(URI.fromString(pathname).toURI())\r\n        }\r\n        lastPathname = pathname\r\n    }\r\n\r\n    historyChanged(History.location ?? {})\r\n    return History.listen(historyChanged)\r\n}\r\n\r\nexport const onSongChanged = (callback: (state?: Spicetify.PlayerState) => void) => {\r\n    callback(Player.data)\r\n    Player.addEventListener(\"songchange\", event => callback(event!.data))\r\n}\r\n\r\nexport const formatUri = (uri: string) => URI.fromString(uri).toURI()\r\n", "// @deno-types=\"npm:@types/lodash\"\r\nimport { default as ld } from \"https://esm.sh/lodash\"\r\nexport const _ = ld\r\n\r\n// @deno-types=\"npm:@types/lodash/fp\"\r\nimport { default as ld_fp } from \"https://esm.sh/lodash/fp\"\r\nexport const fp = ld_fp\r\n", "import { _ } from \"./deps.ts\"\r\n\r\nconst { Snackbar } = Spicetify\r\n\r\ntype async = {\r\n    <A, B>(f: (a: A) => Promise<B>): (fa: Promise<A>) => Promise<B>\r\n    <A, B>(f: (a: A) => B): (fa: Promise<A>) => Promise<B>\r\n}\r\nexport const pMchain: async =\r\n    <A, R>(f: (a: A) => R) =>\r\n    async (fa: A) =>\r\n        f(await fa)\r\n\r\nexport const chunkify50 =\r\n    <A, R>(fn: (a: Array<A>) => R) =>\r\n    async (args: Array<A>) => {\r\n        const a = await Promise.all(_.chunk(args, 50).map(fn))\r\n        return a.flat()\r\n    }\r\n\r\nexport const progressify = <F extends (...args: any) => any>(f: F, n: number) => {\r\n    let i = n,\r\n        lastProgress = 0\r\n    return async function (..._: Parameters<F>): Promise<Awaited<ReturnType<F>>> {\r\n        const res = (await f(...arguments)) as Awaited<ReturnType<F>>,\r\n            progress = Math.round((1 - --i / n) * 100)\r\n        if (progress > lastProgress) {\r\n            ;(Snackbar as any).updater.enqueueSetState(Snackbar, () => ({\r\n                snacks: [],\r\n                queue: [],\r\n            }))\r\n            Snackbar.enqueueSnackbar(`Loading: ${progress}%`, {\r\n                variant: \"default\",\r\n                autoHideDuration: 200,\r\n                transitionDuration: {\r\n                    enter: 0,\r\n                    exit: 0,\r\n                },\r\n            })\r\n        }\r\n        lastProgress = progress\r\n        return res\r\n    }\r\n}\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\n\r\nimport { SettingsSection } from \"../../shared/settings.tsx\"\r\n\r\nconst settings = new SettingsSection(\"Show The Genres\").addInput(\r\n    {\r\n        id: \"LFMApiKey\",\r\n        desc: \"Last.fm API Key\",\r\n        inputType: \"text\",\r\n    },\r\n    task.of(\"********************************\"),\r\n)\r\n\r\nsettings.pushSettings()\r\n\r\nexport const CONFIG = settings.toObject() as {\r\n    LFMApiKey: string\r\n}\r\n", "import { task } from \"https://esm.sh/fp-ts\"\r\nimport { SectionTitle, SettingColumn, SettingSection, SettingText, SettingToggle } from \"./modules.ts\"\r\nimport { sleep } from \"./util.ts\"\r\nimport { _ } from \"./deps.ts\"\r\n\r\nconst { React, ReactDOM, LocalStorage } = Spicetify\r\nconst { ButtonSecondary } = Spicetify.ReactComponent\r\nconst { History } = Spicetify.Platform\r\n\r\ntype FieldToProps<A> = Omit<A, \"type\">\r\n\r\nexport const enum FieldType {\r\n    BUTTON = \"button\",\r\n    TOGGLE = \"toggle\",\r\n    INPUT = \"input\",\r\n    HIDDEN = \"hidden\",\r\n}\r\n\r\nexport interface BaseField {\r\n    id: string\r\n    type: FieldType\r\n    desc: string\r\n}\r\n\r\nexport type SettingsField = HiddenField | InputField | ButtonField | ToggleField\r\n\r\nexport interface ButtonField extends BaseField {\r\n    type: FieldType.BUTTON\r\n    text: string\r\n    onClick?: () => void\r\n}\r\nexport interface ToggleField extends BaseField {\r\n    type: FieldType.TOGGLE\r\n    onSelected?: (checked: boolean) => void\r\n}\r\n\r\nexport interface InputField extends BaseField {\r\n    type: FieldType.INPUT\r\n    inputType: string\r\n    onChange?: (value: string) => void\r\n}\r\n\r\nexport interface HiddenField extends BaseField {\r\n    type: FieldType.HIDDEN\r\n}\r\n\r\nexport class SettingsSection {\r\n    private stopHistoryListener: any\r\n    public id: string\r\n\r\n    constructor(public name: string, public sectionFields: { [key: string]: SettingsField } = {}) {\r\n        this.id = _.kebabCase(name)\r\n    }\r\n\r\n    pushSettings = () => {\r\n        if (this.stopHistoryListener) this.stopHistoryListener()\r\n\r\n        this.stopHistoryListener = History.listen(() => this.render())\r\n        this.render()\r\n    }\r\n\r\n    toObject = () =>\r\n        new Proxy(\r\n            {},\r\n            {\r\n                get: (target, prop) => SettingsSection.getFieldValue(this.getId(prop.toString())),\r\n            },\r\n        )\r\n\r\n    private render = async () => {\r\n        while (!document.getElementById(\"desktop.settings.selectLanguage\")) {\r\n            if (History.location.pathname !== \"/preferences\") return\r\n            await sleep(100)\r\n        }\r\n\r\n        const allSettingsContainer = document.querySelector(\".x-settings-container\")!\r\n\r\n        let pluginSettingsContainer = Array.from(allSettingsContainer.children).find(({ id }) => id === this.id)\r\n\r\n        if (!pluginSettingsContainer) {\r\n            pluginSettingsContainer = document.createElement(\"div\")\r\n            pluginSettingsContainer.id = this.id\r\n            pluginSettingsContainer.className = \"settingsContainer\"\r\n            allSettingsContainer.appendChild(pluginSettingsContainer)\r\n        }\r\n\r\n        ReactDOM.render(<this.SettingsSection />, pluginSettingsContainer)\r\n    }\r\n\r\n    addButton = (props: FieldToProps<ButtonField>) => {\r\n        this.addField(FieldType.BUTTON, props)\r\n        return this\r\n    }\r\n\r\n    addToggle = (props: FieldToProps<ToggleField>, defaultValue = task.of(false)) => {\r\n        this.addField(FieldType.TOGGLE, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    addInput = (props: FieldToProps<InputField>, defaultValue = task.of(\"\")) => {\r\n        this.addField(FieldType.INPUT, props, defaultValue)\r\n        return this\r\n    }\r\n\r\n    private addField(type: FieldType, opts: FieldToProps<SettingsField>, defaultValue?: any) {\r\n        if (defaultValue !== undefined) {\r\n            const settingId = this.getId(opts.id)\r\n            SettingsSection.setDefaultFieldValue(settingId, defaultValue)\r\n        }\r\n        const field = Object.assign({}, opts, { type }) as SettingsField\r\n        this.sectionFields[opts.id] = field\r\n    }\r\n\r\n    getId = (nameId: string) => [\"extensions\", this.id, nameId].join(\":\")\r\n\r\n    private useStateFor = <A,>(id: string) => {\r\n        const [value, setValueState] = React.useState(SettingsSection.getFieldValue<A>(id))\r\n\r\n        return [\r\n            value,\r\n            (newValue: A) => {\r\n                if (newValue !== undefined) {\r\n                    setValueState(newValue)\r\n                    SettingsSection.setFieldValue(id!, newValue)\r\n                }\r\n            },\r\n        ] as const\r\n    }\r\n\r\n    static getFieldValue = <R,>(id: string): R => JSON.parse(LocalStorage.get(id) ?? \"null\")\r\n\r\n    static setFieldValue = (id: string, newValue: any) => LocalStorage.set(id, JSON.stringify(newValue))\r\n\r\n    private static setDefaultFieldValue = async (id: string, defaultValue: task.Task<any>) => {\r\n        if (SettingsSection.getFieldValue(id) === null) SettingsSection.setFieldValue(id, await defaultValue())\r\n    }\r\n\r\n    private toReactComponent = (field: SettingsField) => {\r\n        switch (field.type) {\r\n            case FieldType.BUTTON:\r\n                return this.ButtonField(field)\r\n            case FieldType.TOGGLE:\r\n                return this.ToggleField(field)\r\n            case FieldType.INPUT:\r\n                return this.InputField(field)\r\n            default:\r\n                return <></>\r\n        }\r\n    }\r\n\r\n    private SettingsSection = () => (\r\n        <SettingSection filterMatchQuery={this.name}>\r\n            <SectionTitle>{this.name}</SectionTitle>\r\n            {Object.values(this.sectionFields).map(this.toReactComponent)}\r\n        </SettingSection>\r\n    )\r\n\r\n    SettingField = ({ field, children }: { field: SettingsField; children?: any }) => (\r\n        <SettingColumn filterMatchQuery={field.id}>\r\n            <div className=\"x-settings-firstColumn\">\r\n                <SettingText htmlFor={field.id}>{field.desc}</SettingText>\r\n            </div>\r\n            <div className=\"x-settings-secondColumn\">{children}</div>\r\n        </SettingColumn>\r\n    )\r\n\r\n    ButtonField = (field: ButtonField) => (\r\n        <this.SettingField field={field}>\r\n            <ButtonSecondary id={field.id} buttonSize=\"sm\" onClick={field.onClick} className=\"x-settings-button\">\r\n                {field.text}\r\n            </ButtonSecondary>\r\n        </this.SettingField>\r\n    )\r\n\r\n    ToggleField = (field: ToggleField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<boolean>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <SettingToggle\r\n                    id={field.id}\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    onSelected={(checked: boolean) => {\r\n                        setValue(checked)\r\n                        field.onSelected?.(checked)\r\n                    }}\r\n                    className=\"x-settings-button\"\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n\r\n    InputField = (field: InputField) => {\r\n        const id = this.getId(field.id)\r\n        const [value, setValue] = this.useStateFor<string>(id)\r\n        return (\r\n            <this.SettingField field={field}>\r\n                <input\r\n                    className=\"x-settings-input\"\r\n                    id={field.id}\r\n                    dir=\"ltr\"\r\n                    value={SettingsSection.getFieldValue(id)}\r\n                    type={field.inputType}\r\n                    onChange={e => {\r\n                        const value = e.currentTarget.value\r\n                        setValue(value)\r\n                        field.onChange?.(value)\r\n                    }}\r\n                />\r\n            </this.SettingField>\r\n        )\r\n    }\r\n}\r\n", "import { _ } from \"./deps.ts\"\r\n\r\n// @ts-expect-error webpackChunkOpen is only defined in the browser\r\nconst require = webpackChunkopen.push([[Symbol(\"Dummy module to extract require method\")], {}, re => re])\r\nconst cache = Object.keys(require.m).map(id => require(id))\r\nexport const modules = cache\r\n    .filter((module): module is Object => typeof module === \"object\")\r\n    .flatMap(module => Object.values(module))\r\nexport const functionModules = modules.filter((module): module is Function => typeof module === \"function\")\r\n\r\n// const reactObjects = modules.filter(m => m?.$$typeof)\r\n\r\n// const reactForwardRefSymbol = Spicetify.React.forwardRef().$$typeof\r\n// const reactForwardRefs = reactObjects.filter(m => m.$$typeof === reactForwardRefSymbol)\r\n\r\n// const reactMemoSymbol = Spicetify.React.memo().$$typeof\r\n// const reactMemos = reactObjects.filter(m => m.$$typeof === reactMemoSymbol)\r\n\r\nconst findModuleByStrings = (modules: Array<any>, ...filters: Array<string | RegExp>) =>\r\n    modules.find(f =>\r\n        _.overEvery(\r\n            filters.map(filter =>\r\n                typeof filter === \"string\" ? (s: string) => s.includes(filter) : (s: string) => filter.test(s),\r\n            ),\r\n        )(f.toString()),\r\n    )\r\n\r\nexport const CheckedPlaylistButtonIcon = findModuleByStrings(\r\n    functionModules,\r\n    \"M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8zm11.748-1.97a.75.75 0 0 0-1.06-1.06l-4.47 4.47-1.405-1.406a.75.75 0 1 0-1.061 1.06l2.466 2.467 5.53-5.53z\",\r\n)\r\n\r\nexport const SettingSection = findModuleByStrings(\r\n    functionModules,\r\n    \"function m(e){return(0,d.jsx)(r.k,{children:(0,d.jsx)(u,{...e})})}\",\r\n)\r\nexport const SectionTitle = findModuleByStrings(functionModules, \"textToHighlight\", \"textBase\")\r\nexport const SettingColumn = findModuleByStrings(functionModules, \"setSectionFilterMatchQueryValue\", \"filterMatchQuery\")\r\nexport const SettingText = findModuleByStrings(functionModules, \"textSubdued\", \"viola\")\r\nexport const SettingToggle = findModuleByStrings(functionModules, \"condensed\", \"onSelected\")\r\n\r\nexport const curationButtonClass = modules.find(m => m?.curationButton)!.curationButton\r\n", "import { LitElement, PropertyValues, css, html } from \"https://esm.sh/lit\"\r\nimport { customElement, property, state } from \"https://esm.sh/lit/decorators.js\"\r\nimport { join } from \"https://esm.sh/lit/directives/join.js\"\r\nimport { map } from \"https://esm.sh/lit/directives/map.js\"\r\n\r\nimport { SpotifyURI } from \"../../shared/util.ts\"\r\nimport { _ } from \"../../shared/deps.ts\"\r\n\r\nconst { History } = Spicetify.Platform\r\n\r\ndeclare global {\r\n    interface HTMLElementTagNameMap {\r\n        \"genre-container\": _ArtistGenreContainer\r\n        \"genre-link\": _GenreLink\r\n    }\r\n}\r\n\r\n@customElement(\"genre-link\")\r\nclass _GenreLink extends LitElement {\r\n    static styles = css`\r\n        :host > a {\r\n            color: var(--spice-subtext);\r\n            font-size: var(--genre-link-size);\r\n        }\r\n    `\r\n\r\n    @property()\r\n    genre = \"No Genre\"\r\n\r\n    private openPlaylistsSearch() {\r\n        History.push({ pathname: `/search/${this.genre}/playlists` })\r\n    }\r\n\r\n    protected render() {\r\n        return html`<a href=\"#\" @click=${this.openPlaylistsSearch}>${_.startCase(this.genre)}</a>`\r\n    }\r\n}\r\n\r\n@customElement(\"genre-container\")\r\nclass _ArtistGenreContainer extends LitElement {\r\n    @property()\r\n    name?: string = undefined\r\n\r\n    @property()\r\n    uri?: SpotifyURI = undefined\r\n\r\n    @state()\r\n    genres: string[] = []\r\n\r\n    @property()\r\n    isSmall = true\r\n\r\n    @property()\r\n    fetchGenres = (uri: SpotifyURI) => Promise.resolve([uri])\r\n\r\n    protected willUpdate(changedProperties: PropertyValues<this>) {\r\n        if (changedProperties.has(\"uri\")) {\r\n            this.uri && this.fetchGenres(this.uri).then(genres => (this.genres = genres))\r\n        }\r\n    }\r\n\r\n    protected render() {\r\n        const artistGenreLinks = map(this.genres, genre => html`<genre-link genre=${genre} />`)\r\n        const divider = html`<span>, </span>`\r\n\r\n        return html`<style>\r\n                a {\r\n                    --genre-link-size: ${this.isSmall ? \"12px\" : \"1rem\"};\r\n                }\r\n            </style>\r\n            <div className=\"main-entityHeader-detailsText genre-container\">\r\n                ${this.name && html`<span>${this.name} : </span>`} ${join(artistGenreLinks, () => divider)}\r\n            </div>`\r\n    }\r\n}\r\n", "const { Locale, GraphQL } = Spicetify\r\n\r\ntype fetchArtistRelatedRes = Array<{\r\n    id: string\r\n    uri: string\r\n    profile: {\r\n        name: string\r\n    }\r\n    visuals: {\r\n        avatarImage: {\r\n            sources: Array<Spicetify.Platform.ImageSized>\r\n        }\r\n    }\r\n}>\r\nexport const fetchArtistRelated = async (uri: string) => {\r\n    const res = await GraphQL.Request(GraphQL.Definitions.queryArtistRelated, {\r\n        uri,\r\n        locale: Locale.getLocale(),\r\n    })\r\n\r\n    return res.data.artistUnion.relatedContent.relatedArtists.items as fetchArtistRelatedRes\r\n}\r\n"],
  "mappings": "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",
  "names": ["toMatchTo", "res", "f", "task", "require", "modules", "f", "History", "History", "value", "task", "History", "URI", "state", "artistsUris", "a", "uri"]
}
